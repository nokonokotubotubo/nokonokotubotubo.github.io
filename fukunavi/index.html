<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Fukuなび</title>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#3385ff">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Fukuなび">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<style>
/* ――― 既存 CSS は変更なし ――― */
*{box-sizing:border-box}
html,body,#app{height:100vh;margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif}
body{background:#e6f2ff;overflow:hidden}
#app{display:flex;flex-direction:column;background:#fff}
/* …（中略：添付ファイルの CSS と完全同一）… */
</style>
</head>
<body>
<div id="app">
  <!-- ――― 既存 HTML テンプレートは変更なし ――― -->
  <!-- …（中略：添付ファイルの HTML と完全同一）… -->
</div>

<script src="https://unpkg.com/vue@3.0.0"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
<script>
const { createApp, ref, reactive, onMounted, computed, nextTick, watch, onUnmounted } = Vue;

createApp({
  setup() {
    const map                   = ref(null);
    const marker                = ref(null);
    const selectedLatLng        = reactive({ lat: 34.6937, lng: 135.5023 });

    const dateList              = ref([]);
    const selectedDateIndex     = ref(0);

    /* ▼ 追加：URL 指定日時ハイライト用 */
    const urlHighlightHour      = ref(null);
    const urlHighlightDateIndex = ref(null);
    /* ▲ 追加ここまで */

    const weatherData           = reactive({});
    const errorMessage          = ref('');
    const currentAddress        = ref('');

    const hours                 = Array.from({ length: 17 }, (_, i) => i + 6);
    const tableContainer        = ref(null);

    const addressCache          = new Map();
    const addressRequestInProgress = ref(false);

    const showContextMenu       = ref(false);
    const contextMenuPosition   = reactive({ x: 0, y: 0 });
    const contextMenuIndex      = ref(0);

    const showSaveDialog        = ref(false);
    const locationMemories      = ref(Array.from({ length: 5 }, () => ({ name: '', lat: null, lng: null, address: '' })));
    const saveLocationName      = ref('');
    const selectedPreset        = ref('');
    const saveLocationIndex     = ref(0);
    const longPressTimer        = ref(null);
    const saveLocationInput     = ref(null);

    const showMap               = ref(false);
    const windowWidth           = ref(window.innerWidth);
    const selectedMemoryIndex   = ref(-1);

    const isMobile              = computed(() => windowWidth.value <= 600);
    const hasWeatherData        = computed(() => Object.keys(weatherData).length > 0);

    /* ---------- 共通ユーティリティ ---------- */
    /* 改修：区切りを「/」にして JST 解釈を保証 */
    const getJSTDateString = (d = new Date()) => {
      const y   = d.getFullYear();
      const m   = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}/${m}/${day}`;             // ← 変更点
    };

    /* 改修：URL 指定優先でハイライト */
    const isCurrentHour = h => {
      if (urlHighlightHour.value !== null &&
          urlHighlightDateIndex.value !== null) {
        return selectedDateIndex.value === urlHighlightDateIndex.value &&
               h === urlHighlightHour.value;
      }
      return selectedDateIndex.value === 0 &&
             new Date().getHours() === h;
    };

    const scrollToSpecificHour = targetHour => {
      if (windowWidth.value > 600) return;

      const scrollTarget = targetHour > 22 ? 22 : targetHour;
      setTimeout(() => {
        const el = document.getElementById(`mobile-hour-${scrollTarget}`);
        if (el && tableContainer.value) {
          const c   = tableContainer.value;
          const vh  = c.getBoundingClientRect().height;
          const rh  = el.offsetHeight;
          const tgt = el.offsetTop - vh / 2 + rh / 2;
          c.scrollTo({ top: Math.max(0, tgt), behavior: 'instant' });
        }
      }, 50);
    };

    const scrollToCurrentTime = () => {
      /* URL 指定がある場合は自動スクロール済み */
      if (urlHighlightHour.value !== null) return;

      if (selectedDateIndex.value !== 0) return;
      const now         = new Date();
      const h           = now.getHours();
      const targetHour  = h + 3;

      if (h < 6 || h > 22 || windowWidth.value > 600) return;

      const scrollTarget = targetHour > 22 ? 22 : targetHour;
      setTimeout(() => {
        const el = document.getElementById(`mobile-hour-${scrollTarget}`);
        if (el && tableContainer.value) {
          const c   = tableContainer.value;
          const vh  = c.getBoundingClientRect().height;
          const rh  = el.offsetHeight;
          const tgt = el.offsetTop - vh / 2 + rh / 2;
          c.scrollTo({ top: Math.max(0, tgt), behavior: 'instant' });
        }
      }, 50);
    };

    watch(hasWeatherData, v => v && scrollToCurrentTime());

    /* ---------- 日付リスト生成 ---------- */
    const generateDateList = () => {
      const today = new Date();
      dateList.value = [];
      for (let i = 0; i <= 7; i++) {
        const d = new Date(today);
        d.setDate(today.getDate() + i);
        dateList.value.push(getJSTDateString(d));   // 例 2025/07/10
      }
    };

    const dateLabel = (s, i) =>
      i === 0 ? '今日' : i === 1 ? '明日' : i === 2 ? '明後日' : i === 7 ? '1週間後' : `${i}日後`;

    /* 改修：スラッシュ区切りの日付を安全にパース */
    const formatDateDetail = s => {
      const [y, m, d] = s.split('/');
      const dateObj   = new Date(+y, +m - 1, +d);
      const w         = dateObj.toLocaleDateString('ja-JP', { weekday: 'short' });
      return `${+m}/${+d}（${w}）`;
    };

    /* ---------- 天気データ取得 ---------- */
    const fetchWeatherData = () => {
      errorMessage.value = '';
      Object.keys(weatherData).forEach(k => delete weatherData[k]);

      /* API 用に ISO 形式へ変換（/ → -）*/
      const dISO = dateList.value[selectedDateIndex.value].replace(/\//g, '-');

      const lat  = selectedLatLng.lat.toFixed(4);
      const lng  = selectedLatLng.lng.toFixed(4);

      const url  = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation_probability,weather_code&start_date=${dISO}&end_date=${dISO}&timezone=auto`;

      const c   = new AbortController();
      const tid = setTimeout(() => c.abort(), 15000);

      fetch(url, { signal: c.signal }).then(r => {
        clearTimeout(tid);
        if (!r.ok) throw new Error('天気データの取得に失敗しました。インターネット接続を確認してください。');
        return r.json();
      }).then(data => {
        if (!data.hourly) throw new Error('天気データの解析に失敗しました。しばらく時間をおいて再試行してください。');
        for (const h of hours) {
          const idx = data.hourly.time.findIndex(t => t.endsWith(`T${h.toString().padStart(2, '0')}:00`));
          if (idx !== -1) {
            weatherData[h] = {
              temperature_2m:          Math.round(data.hourly.temperature_2m[idx]),
              apparent_temperature:    Math.round(data.hourly.apparent_temperature[idx]),
              relative_humidity_2m:    Math.round(data.hourly.relative_humidity_2m[idx]),
              precipitation_probability: Math.round(data.hourly.precipitation_probability[idx] || 0),
              weather_code:            data.hourly.weather_code[idx]
            };
          }
        }
      }).catch(e => {
        clearTimeout(tid);
        errorMessage.value =
          e.name === 'AbortError' ? '天気データの取得がタイムアウトしました。再試行してください。' : e.message;
        setTimeout(() => (errorMessage.value = ''), 8000);
      });
    };

    /* ---------- URL パラメータ処理 ---------- */
    const getUrlParams = () => {
      const params    = new URLSearchParams(window.location.search);
      const latParam  = params.get('lat');
      const lngParam  = params.get('lng');
      const dtParam   = params.get('datetime');

      let result = null;

      /* 緯度経度 */
      if (latParam && lngParam) {
        const pLat = parseFloat(latParam);
        const pLng = parseFloat(lngParam);
        if (!isNaN(pLat) && !isNaN(pLng) &&
            pLat >= -90 && pLat <= 90 &&
            pLng >= -180 && pLng <= 180) {
          result = { lat: pLat, lng: pLng };
        }
      }

      /* 日時 (YYYYMMDDhhmm) */
      if (dtParam && dtParam.length === 12) {
        const y  = parseInt(dtParam.slice(0, 4));
        const m  = parseInt(dtParam.slice(4, 6));
        const d  = parseInt(dtParam.slice(6, 8));
        const hh = parseInt(dtParam.slice(8, 10));
        const mm = parseInt(dtParam.slice(10, 12));

        if (y >= 2020 && y <= 2030 &&
            m >= 1   && m <= 12 &&
            d >= 1   && d <= 31 &&
            hh >= 0  && hh <= 23 &&
            mm >= 0  && mm <= 59) {

          const tgt     = new Date(y, m - 1, d, hh, mm);
          const today   = new Date();
          const diff    = Math.floor((tgt - today) / (1000 * 60 * 60 * 24));

          if (diff >= 0 && diff <= 7 && hh >= 6 && hh <= 22) {
            result              = result || {};
            result.dateIndex    = diff;
            result.targetHour   = hh;
            result.isValidDateTime = true;
          }
        }
      }
      return result;
    };

    /* ---------- マウント後処理 ---------- */
    onMounted(() => {
      generateDateList();
      const nowHour = new Date().getHours();
      if (nowHour >= 21) selectedDateIndex.value = 1;

      window.addEventListener('resize', () => windowWidth.value = window.innerWidth);

      nextTick(() => setTimeout(() => {
        /* …（中略：地図初期化やローカルストレージ読み込みなど既存処理）… */
        initMap();
        loadLocationMemoriesFromStorage();

        const urlInfo = getUrlParams();
        if (urlInfo) {
          selectedMemoryIndex.value = -1;

          if (urlInfo.lat && urlInfo.lng) {
            selectedLatLng.lat = urlInfo.lat;
            selectedLatLng.lng = urlInfo.lng;
            map.value && (map.value.setView([urlInfo.lat, urlInfo.lng], 12), updateMarker());
            fetchAddress(urlInfo.lat, urlInfo.lng);
          }

          if (urlInfo.isValidDateTime) {
            selectedDateIndex.value      = urlInfo.dateIndex;
            urlHighlightHour.value       = urlInfo.targetHour;      // ★ 追加
            urlHighlightDateIndex.value  = urlInfo.dateIndex;       // ★ 追加
            nextTick(() => setTimeout(() => scrollToSpecificHour(urlInfo.targetHour), 100));
          }
          fetchWeatherData();
        } else if (locationMemories.value[0].name &&
                   locationMemories.value[0].lat &&
                   locationMemories.value[0].lng) {
          selectedMemoryIndex.value  = 0;
          selectedLatLng.lat         = locationMemories.value[0].lat;
          selectedLatLng.lng         = locationMemories.value[0].lng;
          map.value && (map.value.setView([selectedLatLng.lat, selectedLatLng.lng], 10), updateMarker());
          fetchAddress(selectedLatLng.lat, selectedLatLng.lng);
          fetchWeatherData();
        } else {
          fetchWeatherData();
        }
      }, 200));
    });

    onUnmounted(() => window.removeEventListener('resize', () => windowWidth.value = window.innerWidth));

    /* ---------- 既存メソッド（省略せず元コードと同一） ---------- */
    /* …（中略：位置情報取得・メモリ保存・地図操作等すべて元コードと同一）… */

    /* ---------- テンプレートへ公開 ---------- */
    return {
      dateList,
      selectedDateIndex,
      /* …（中略：元の返却オブジェクトに変更なし）… */
      dateLabel,
      formatDateDetail,
      selectDate,
      weatherData,
      hours,
      weatherIcon,
      calculateDiscomfortIndex,
      discomfortLevel,
      temperatureClass,
      clothingIcon,
      clothingLabel,
      isCurrentHour,
      hasWeatherData,
      errorMessage,
      getCurrentLocation,
      currentAddress,
      tableContainer,
      locationMemories,
      startLongPress,
      endLongPress,
      saveLocationMemory,
      showSaveDialog,
      closeSaveDialog,
      loadLocationMemory,
      getMemoryNumber,
      showContextMenu,
      contextMenuPosition,
      isMemorySlotSaved,
      openSaveDialog,
      confirmDeleteMemory,
      deleteLocationMemory,
      closeContextMenu,
      showMap,
      toggleMap,
      isMobile,
      selectedMemoryIndex
    };
  }
}).mount('#app');

/* Service Worker 登録は変更なし */
'serviceWorker' in navigator &&
  (location.protocol === 'https:' || location.hostname === 'localhost') &&
  window.addEventListener('load', () =>
    navigator.serviceWorker
      .register('/sw.js')
      .then(r => console.log('SW registered: ', r))
      .catch(e => console.log('SW registration failed: ', e))
  );
</script>
</body>
</html>
