<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„É°„É¢„Ç¢„Éó„É™</title>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
:root { --bg-primary: #F7FBFF; --bg-surface: #EAF5FF; --color-primary: #5BBDF7; --color-accent: #4A90E2; --border-color: #D6EAFB; --text-color: #0F2942; --radius: 8px; --shadow: 0 2px 4px rgba(2,6,23,0.1); }

body, html { margin: 0; padding: 0; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: var(--bg-primary); color: var(--text-color); display: flex; flex-direction: column; overflow: hidden; }

.app-container { display: flex; flex-grow: 1; overflow: hidden; }

.app-header { height: 50px; flex-shrink: 0; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; padding: 0 8px; background-color: #fff; justify-content: space-between; }

.app-header__title-input { flex-grow: 1; border: none; background: transparent; font-size: 1.2em; color: var(--text-color); outline: none; font-weight: 500; }

.app-header__actions { display: flex; align-items: center; }

.app-header__actions button, .app-header__actions label { background-color: var(--color-accent); color: white; border: none; border-radius: var(--radius); padding: 8px 12px; cursor: pointer; margin-left: 8px; font-weight: 500; transition: background-color 0.2s; font-size: 14px; text-align: center; }

.app-header__actions button:hover, .app-header__actions label:hover { background-color: #357ABD; }

#trash-btn { font-size: 18px; padding: 6px 8px; line-height: 1.2; }

#import-input { display: none; }

.app-sidebar { width: 300px; flex-shrink: 0; border-right: 1px solid var(--border-color); background-color: var(--bg-surface); display: flex; flex-direction: column; }

.app-sidebar__search { padding: 8px; border-bottom: 1px solid var(--border-color); }

.app-sidebar__search-input { width: 100%; box-sizing: border-box; padding: 8px; border-radius: var(--radius); border: 1px solid var(--border-color); }

.app-sidebar__unified-tree { flex-grow: 1; overflow-y: auto; padding: 8px; }

.tree-item { position: relative; padding: 8px; cursor: pointer; border-radius: var(--radius); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; justify-content: space-between; }

.tree-item:hover { background-color: #dbefff; }

.tree-item.active { background-color: var(--color-primary); color: white; }

.tree-item.folder { font-weight: 500; }

.tree-item.folder .folder-toggle { display: inline-block; width: 16px; text-align: center; margin-right: 0px; user-select: none; }

.tree-item.folder .folder-icon-name { display: flex; align-items: center; flex-grow: 1; }

.tree-item.folder::before { content: ''; }

.tree-item.memo::before { content: 'üìù'; margin-right: 8px; }

.tree-item[data-level="0"] { padding-left: 8px; }

.tree-item[data-level="1"] { padding-left: 24px; }

.tree-item[data-level="2"] { padding-left: 40px; }

.tree-item[data-level="3"] { padding-left: 56px; }

.tree-item__snippet { font-size: 0.8em; opacity: 0.7; margin-left: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

.tree-item__snippet mark { background-color: #fff3a3; border-radius: 3px; color: #333; }

/* „Çø„Ç§„Éà„É´ÈÉ®ÂàÜ„ÅÆ„Ç≥„É≥„ÉÜ„Éä */
.tree-item > div:first-child {
flex: 1;
min-width: 0;
margin-right: 8px;
}

/* „Çø„Ç§„Éà„É´„ÉÜ„Ç≠„Çπ„Éà */
.tree-item > div:first-child > span {
display: block;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
max-width: 100%;
}

/* ‰∏¶„Å≥Êõø„Åà„Éú„Çø„É≥„ÅÆ„Çπ„Çø„Ç§„É´ */
.sort-buttons {
display: none;
flex-shrink: 0;
z-index: 10;
position: relative;
margin-left: auto;
margin-right: 8px;
width: 24px;
}

.tree-item:hover .sort-buttons {
display: flex;
flex-direction: column;
}

.sort-btn {
background: none;
border: none;
cursor: pointer;
font-size: 12px;
line-height: 1;
padding: 1px 4px;
color: var(--text-color);
opacity: 0.6;
transition: opacity 0.2s;
z-index: 11;
position: relative;
}

.sort-btn:hover {
opacity: 1;
background-color: rgba(0,0,0,0.1);
border-radius: 2px;
}

.tree-item.active .sort-btn {
color: white;
}

.tree-item.active .sort-btn:hover {
background-color: rgba(255,255,255,0.2);
}

/* Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆ„Çπ„Çø„Ç§„É´ */
.context-menu { position: fixed; background: white; border: 1px solid var(--border-color); border-radius: var(--radius); padding: 4px 0; box-shadow: var(--shadow); z-index: 1000; min-width: 120px; display: none; }

.context-menu-item { padding: 8px 16px; cursor: pointer; font-size: 14px; }

.context-menu-item:hover { background-color: var(--bg-surface); }

.context-menu-item.disabled { color: #999; cursor: not-allowed; }

.context-menu-item.disabled:hover { background-color: transparent; }

.context-menu-separator { height: 1px; background-color: var(--border-color); margin: 4px 0; }

.app-main { flex-grow: 1; display: flex; flex-direction: column; position: relative; }

#editor-container { flex-grow: 1; height: 100%; }

#editor-footer { position: absolute; bottom: 5px; right: 10px; font-size: 16px; color: #666; }

.ql-editor { font-size: 16px; line-height: 1.6; }

.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(47, 144, 226, 0.15); display: none; justify-content: flex-start; align-items: center; z-index: 1000; padding-left: 20px; }

.modal-overlay.visible { display: flex; }

.modal-content { background: var(--bg-primary); padding: 20px; border-radius: var(--radius); width: 80%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column; border: 1px solid var(--border-color); box-shadow: 0 8px 24px rgba(91, 189, 247, 0.15); }

.modal-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--color-primary); color: white; border-radius: var(--radius) var(--radius) 0 0; padding: 15px 20px; margin: -20px -20px 15px -20px; border-bottom: none; }

.modal-close-btn { font-size: 1.5rem; cursor: pointer; border: none; background: none; color: white; opacity: 0.8; transition: opacity 0.2s; }

.modal-close-btn:hover { opacity: 1; }

.modal-body { flex-grow: 1; overflow-y: auto; }

.list-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); }

.list-item:last-child { border-bottom: none; }

.list-item__name::before { content: 'üìù'; margin-right: 8px; }

.list-item__name.folder::before { content: 'üìÅ'; }

#empty-trash-btn {
background-color: #c0392b;
color: white;
border: none;
border-radius: var(--radius);
padding: 6px 10px;
cursor: pointer;
font-size: 13px;
margin-right: 10px;
transition: background-color 0.2s;
}

#trash-btn, #settings-btn {
font-size: 18px;
width: 36px;
height: 36px;
border-radius: 50%;
padding: 0;
display: inline-flex;
align-items: center;
justify-content: center;
background-color: var(--bg-surface);
color: var(--text-color);
border: 1px solid var(--border-color);
transition: background-color 0.2s, border-color 0.2s;
}

#trash-btn:hover, #settings-btn:hover {
background-color: #dbefff;
border-color: #cce4ff;
}

#empty-trash-btn:hover {
background-color: #a93226;
}

.settings-section {
margin-bottom: 20px;
}

.settings-section h3 {
margin-top: 0;
margin-bottom: 15px;
border-bottom: 1px solid var(--border-color);
padding-bottom: 10px;
}

.settings-buttons {
display: flex;
flex-wrap: wrap;
gap: 12px;
}

.settings-buttons button, .settings-buttons .settings-label-btn {
flex: 1;
min-width: 120px;
max-width: 180px;
padding: 10px 16px;
font-size: 14px;
background-color: var(--color-accent);
color: white;
border: none;
border-radius: var(--radius);
cursor: pointer;
text-align: center;
transition: background-color 0.2s;
font-weight: 500;
}

.settings-buttons button:hover, .settings-buttons .settings-label-btn:hover {
background-color: #357ABD;
}

.dialog-content {
background: var(--bg-primary);
padding: 25px;
border-radius: var(--radius);
width: 350px;
max-width: none;
box-shadow: 0 8px 24px rgba(91, 189, 247, 0.15);
text-align: center;
margin: 0;
border: 1px solid var(--border-color);
}

.dialog-content h3 {
background-color: var(--color-primary);
color: white;
margin: -25px -25px 20px -25px;
padding: 15px 25px;
border-radius: var(--radius) var(--radius) 0 0;
font-weight: 500;
}

.dialog-content p {
margin-top: 0;
margin-bottom: 20px;
color: #555;
}

.dialog-input {
width: 100%;
padding: 10px;
border: 1px solid var(--border-color);
border-radius: var(--radius);
margin-bottom: 20px;
box-sizing: border-box;
}

.dialog-buttons {
display: flex;
justify-content: center;
gap: 10px;
}

.dialog-buttons button {
border: none;
border-radius: var(--radius);
padding: 10px 20px;
cursor: pointer;
font-weight: 500;
transition: background-color 0.2s, box-shadow 0.2s;
}

#dialog-ok-btn {
background-color: var(--color-accent);
color: white;
}

#dialog-ok-btn:hover {
background-color: #357ABD;
}

#dialog-cancel-btn {
background-color: #f0f0f0;
color: #333;
}

#dialog-cancel-btn:hover {
background-color: #e0e0e0;
}

#backup-modal-overlay, #custom-dialog-overlay {
z-index: 1002;
}

/* „Ç¥„ÉüÁÆ±„ÄÅË®≠ÂÆö„ÄÅ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„É¢„Éº„ÉÄ„É´„ÇíÂè≥‰∏ä„Å´ÈÖçÁΩÆ */
#trash-modal-overlay, #settings-modal-overlay, #backup-modal-overlay {
justify-content: flex-end !important;
align-items: flex-start !important;
padding-left: 0 !important;
padding-right: 20px !important;
padding-top: 20px !important;
}

/* ÁâπÂÆö„ÅÆ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅÆ„ÅøÂè≥‰∏ä„Å´ÈÖçÁΩÆ */
#custom-dialog-overlay.position-top-right {
justify-content: flex-end !important;
align-items: flex-start !important;
padding-left: 0 !important;
padding-right: 20px !important;
padding-top: 20px !important;
}

/* Ë≠¶Âëä„Çπ„Çø„Ç§„É´ */
.backup-warning {
background-color: #E8F4FD;
border: 1px solid var(--color-primary);
border-radius: var(--radius);
padding: 12px;
margin-bottom: 15px;
font-size: 0.9em;
color: var(--text-color);
}
    </style>
</head>
<body>
    <div class="app-header">
        <input type="text" class="app-header__title-input" placeholder="„Çø„Ç§„Éà„É´„ÇíÂÖ•Âäõ">
        <div class="app-header__actions">
            <button id="trash-btn" title="„Ç¥„ÉüÁÆ±">üóëÔ∏è</button>
            <button id="settings-btn" title="Ë®≠ÂÆö">‚öôÔ∏è</button>
        </div>
    </div>

    <div class="app-container">
        <div class="app-sidebar">
            <div class="app-sidebar__search">
                <input type="text" class="app-sidebar__search-input" placeholder="Ê§úÁ¥¢">
            </div>
            <div class="app-sidebar__unified-tree">
                <div id="unified-tree-container"></div>
            </div>
        </div>

        <div class="app-main">
            <div id="editor-container"></div>
            <div id="editor-footer"></div>
        </div>
    </div>

    <!-- „Ç¥„ÉüÁÆ±„É¢„Éº„ÉÄ„É´ -->
    <div class="modal-overlay" id="trash-modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>„Ç¥„ÉüÁÆ±</h3>
                <button class="modal-close-btn">√ó</button>
            </div>
            <div class="modal-body">
                <button id="empty-trash-btn">„Ç¥„ÉüÁÆ±„ÇíÁ©∫„Å´„Åô„Çã</button>
                <div id="trash-list-container"></div>
            </div>
        </div>
    </div>

    <!-- Ë®≠ÂÆö„É¢„Éº„ÉÄ„É´ -->
    <div class="modal-overlay" id="settings-modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Ë®≠ÂÆö</h3>
                <button class="modal-close-btn">√ó</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h3>„Éá„Éº„ÇøÁÆ°ÁêÜ</h3>
                    <div class="settings-buttons">
                        <button id="export-btn-settings" class="settings-label-btn">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
                        <label for="import-input-settings" class="settings-label-btn">„Ç§„É≥„Éù„Éº„Éà</label>
                        <input type="file" id="import-input-settings" accept=".json" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" data-action="newMemo">Êñ∞„Åó„ÅÑ„É°„É¢</div>
        <div class="context-menu-item" data-action="newFolder">Êñ∞„Åó„ÅÑ„Éï„Ç©„É´„ÉÄ</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="rename">ÂêçÂâç„ÇíÂ§âÊõ¥</div>
        <div class="context-menu-item" data-action="copy">„Ç≥„Éî„Éº</div>
        <div class="context-menu-item" data-action="paste">Ë≤º„Çä‰ªò„Åë</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="delete">ÂâäÈô§</div>
    </div>

    <!-- „Ç´„Çπ„Çø„É†„ÉÄ„Ç§„Ç¢„É≠„Ç∞ -->
    <div class="modal-overlay" id="custom-dialog-overlay">
        <div class="dialog-content">
            <h3 id="dialog-title">Á¢∫Ë™ç</h3>
            <p id="dialog-message">„É°„ÉÉ„Çª„Éº„Ç∏</p>
            <input type="text" id="dialog-input" class="dialog-input" style="display: none;">
            <div class="dialog-buttons">
                <button id="dialog-ok-btn">OK</button>
                <button id="dialog-cancel-btn">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <script>
document.addEventListener('DOMContentLoaded', () => {
    const dataManager = {
        DB_KEY: 'memoAppData',
        db: null,
        
        init() {
            this.loadDataFromStorage();
            if (!this.db) {
                const data = {
                    version: "1.0",
                    folders: [],
                    memos: [],
                    settings: {
                        theme: "light_blue",
                        autoSave: true,
                        activeMemoId: null,
                        activeFolderId: null
                    }
                };
                this.setData(data, 'init');
            }
        },

        loadDataFromStorage() {
            try {
                const data = localStorage.getItem(this.DB_KEY);
                this.db = data ? JSON.parse(data) : null;
            } catch (e) {
                console.error("Error reading data from localStorage", e);
                this.db = null;
            }
        },

        getData() {
            return this.db;
        },

        setData(d, caller = 'unknown') {
            this.db = d;
            try {
                localStorage.setItem(this.DB_KEY, JSON.stringify(d));
            } catch (e) {
                console.error("LS Error:", e);
            }
        },

        formatDateTime(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            const dayNames = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
            const dayOfWeek = dayNames[date.getDay()];
            return `${year}/${month}/${day}(${dayOfWeek}) ${hours}:${minutes}:${seconds}`;
        },

        updateMemo(id, { title: newTitle, content: newContent }) {
            const memo = this.db.memos.find(m => m.id === id);
            if (memo) {
                if (memo.title !== newTitle || memo.content !== newContent) {
                    memo.title = newTitle;
                    memo.content = newContent;
                    memo.updatedAt = new Date().toISOString();
                    this.setData(this.db, 'updateMemo');
                }
                return memo;
            }
            return null;
        },

        renameMemo(id, newTitle) {
            const memo = this.db.memos.find(m => m.id === id);
            if (memo) {
                if (memo.title !== newTitle) {
                    memo.title = newTitle;
                    memo.updatedAt = new Date().toISOString();
                    this.setData(this.db, 'renameMemo');
                }
                return memo;
            }
            return null;
        },

        renameFolder(id, newName) {
            const folder = this.db.folders.find(f => f.id === id);
            if (folder) {
                folder.name = newName;
                this.setData(this.db, 'renameFolder');
                return true;
            }
            return false;
        },

        createMemo(folderId) {
            const d = this.getData();
            const n = new Date().toISOString();
            const newTitle = this.generateUniqueMemoTitle();
            const m = {
                id: crypto.randomUUID(),
                title: newTitle,
                content: "<p></p>",
                folderId: folderId,
                createdAt: n,
                updatedAt: n,
                isTrash: false
            };
            d.memos.push(m);
            this.setData(d, 'createMemo');
            return m;
        },

        generateUniqueMemoTitle() {
            const now = new Date();
            const baseTitle = this.formatDateTime(now);
            const existingTitles = new Set(this.db.memos.filter(m => !m.isTrash).map(m => m.title));
            
            if (!existingTitles.has(baseTitle)) {
                return baseTitle;
            }
            
            let counter = 1;
            while (true) {
                const newTitle = `${baseTitle}_${counter}`;
                if (!existingTitles.has(newTitle)) {
                    return newTitle;
                }
                counter++;
            }
        },

        createFolder(n, p) {
            const d = this.getData();
            const t = new Date().toISOString();
            const f = {
                id: crypto.randomUUID(),
                name: n,
                parentId: p,
                createdAt: t,
                isTrash: false,
                isCollapsed: false
            };
            d.folders.push(f);
            this.setData(d, 'createFolder');
            return f;
        },

        toggleFolderCollapse(id) {
            const d = this.getData();
            const f = d.folders.find(f => f.id === id);
            if (f) {
                f.isCollapsed = !f.isCollapsed;
                this.setData(d, 'toggleFolderCollapse');
            }
        },

        deleteMemo(id) {
            const db = this.getData();
            const memo = db.memos.find(m => m.id === id);
            if (memo) {
                memo.isTrash = true;
                memo.updatedAt = new Date().toISOString();
                this.setData(db, 'deleteMemo');
            }
        },

        deleteFolder(folderId) {
            const db = this.getData();
            const foldersToDelete = new Set([folderId]);
            const memosToDelete = new Set();
            
            const findChildren = (parentId) => {
                db.folders.filter(f => f.parentId === parentId).forEach(f => {
                    foldersToDelete.add(f.id);
                    findChildren(f.id);
                });
                db.memos.filter(m => m.folderId === parentId).forEach(m => memosToDelete.add(m.id));
            };
            
            findChildren(folderId);
            
            const now = new Date().toISOString();
            db.folders.forEach(f => {
                if (foldersToDelete.has(f.id)) {
                    f.isTrash = true;
                    f.updatedAt = now;
                }
            });
            
            db.memos.forEach(m => {
                if (memosToDelete.has(m.id) || m.folderId === folderId) {
                    m.isTrash = true;
                    m.updatedAt = now;
                }
            });
            
            this.setData(db, 'deleteFolder');
        },

        getTrashedItems() {
            const db = this.getData();
            return {
                memos: db.memos.filter(m => m.isTrash),
                folders: db.folders.filter(f => f.isTrash)
            };
        },

        restoreItem(id, type) {
            const db = this.getData();
            if (type === 'memo') {
                const item = db.memos.find(i => i.id === id);
                if (item) item.isTrash = false;
            } else {
                const folder = db.folders.find(f => f.id === id);
                if (folder) {
                    folder.isTrash = false;
                    let parent = db.folders.find(f => f.id === folder.parentId);
                    while(parent && parent.isTrash) {
                        parent.isTrash = false;
                        parent = db.folders.find(f => f.id === parent.parentId);
                    }
                }
            }
            this.setData(db, 'restoreItem');
        },

        deleteItemPermanently(id, type) {
            const db = this.getData();
            if (type === 'memo') {
                db.memos = db.memos.filter(i => i.id !== id);
            } else {
                db.folders = db.folders.filter(i => i.id !== id);
            }
            this.setData(db, 'deleteItemPermanently');
        },

        emptyTrash() {
            const db = this.getData();
            db.memos = db.memos.filter(m => !m.isTrash);
            db.folders = db.folders.filter(f => !f.isTrash);
            this.setData(db, 'emptyTrash');
        },

        // „Ç≥„Éî„Éº„ÉªË≤º„Çä‰ªò„ÅëÊ©üËÉΩ
        copyItem(id, type) {
            const db = this.getData();
            if (type === 'memo') {
                const memo = db.memos.find(m => m.id === id && !m.isTrash);
                if (memo) {
                    return {
                        type: 'memo',
                        data: {
                            title: memo.title + ' „ÅÆ„Ç≥„Éî„Éº',
                            content: memo.content,
                            folderId: memo.folderId
                        }
                    };
                }
            } else if (type === 'folder') {
                const folder = db.folders.find(f => f.id === id && !f.isTrash);
                if (folder) {
                    const copyFolderRecursive = (folderId) => {
                        const folderToCopy = db.folders.find(f => f.id === folderId && !f.isTrash);
                        if (!folderToCopy) return null;
                        
                        const copiedFolder = {
                            name: folderToCopy.name + ' „ÅÆ„Ç≥„Éî„Éº',
                            parentId: folderToCopy.parentId,
                            isCollapsed: false
                        };
                        
                        const childFolders = db.folders
                            .filter(f => f.parentId === folderId && !f.isTrash)
                            .map(f => copyFolderRecursive(f.id))
                            .filter(f => f !== null);
                        
                        const childMemos = db.memos
                            .filter(m => m.folderId === folderId && !m.isTrash)
                            .map(m => ({
                                title: m.title,
                                content: m.content
                            }));
                        
                        return {
                            ...copiedFolder,
                            childFolders,
                            childMemos
                        };
                    };
                    
                    return {
                        type: 'folder',
                        data: copyFolderRecursive(id)
                    };
                }
            }
            return null;
        },

        pasteItem(copiedItem, targetFolderId) {
            if (!copiedItem) return false;
            
            const db = this.getData();
            const now = new Date().toISOString();
            
            if (copiedItem.type === 'memo') {
                const newMemo = {
                    id: crypto.randomUUID(),
                    title: copiedItem.data.title,
                    content: copiedItem.data.content,
                    folderId: targetFolderId,
                    createdAt: now,
                    updatedAt: now,
                    isTrash: false
                };
                db.memos.push(newMemo);
                this.setData(db, 'pasteItem');
                return newMemo;
            } else if (copiedItem.type === 'folder') {
                const pasteFolderRecursive = (folderData, parentId) => {
                    const newFolder = {
                        id: crypto.randomUUID(),
                        name: folderData.name,
                        parentId: parentId,
                        createdAt: now,
                        isTrash: false,
                        isCollapsed: folderData.isCollapsed
                    };
                    db.folders.push(newFolder);
                    
                    folderData.childMemos.forEach(memoData => {
                        const newMemo = {
                            id: crypto.randomUUID(),
                            title: memoData.title,
                            content: memoData.content,
                            folderId: newFolder.id,
                            createdAt: now,
                            updatedAt: now,
                            isTrash: false
                        };
                        db.memos.push(newMemo);
                    });
                    
                    folderData.childFolders.forEach(childFolderData => {
                        pasteFolderRecursive(childFolderData, newFolder.id);
                    });
                    
                    return newFolder;
                };
                
                const newFolder = pasteFolderRecursive(copiedItem.data, targetFolderId);
                this.setData(db, 'pasteItem');
                return newFolder;
            }
            
            return false;
        },

        // ‰∏¶„Å≥Êõø„ÅàÊ©üËÉΩ
        moveItem(id, type, direction, parentId) {
            const db = this.getData();
            let items;
            
            if (type === 'folder') {
                items = db.folders.filter(f => f.parentId === parentId && !f.isTrash);
            } else {
                items = db.memos.filter(m => m.folderId === parentId && !m.isTrash);
            }
            
            // sortOrder„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÂàùÊúüÂåñ
            items.forEach((item, index) => {
                if (item.sortOrder === undefined) {
                    item.sortOrder = index;
                }
            });
            
            // ÁèæÂú®„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíË¶ã„Å§„Åë„Çã
            const currentItem = items.find(item => item.id === id);
            if (!currentItem) return false;
            
            // sortOrder„Åß„ÇΩ„Éº„Éà
            items.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
            
            const currentIndex = items.findIndex(item => item.id === id);
            let targetIndex;
            
            if (direction === 'up') {
                targetIndex = Math.max(0, currentIndex - 1);
            } else {
                targetIndex = Math.min(items.length - 1, currentIndex + 1);
            }
            
            if (currentIndex === targetIndex) return false;
            
            // „Ç¢„Ç§„ÉÜ„É†„ÅÆ‰ΩçÁΩÆ„Çí‰∫§Êèõ
            const temp = items[currentIndex].sortOrder;
            items[currentIndex].sortOrder = items[targetIndex].sortOrder;
            items[targetIndex].sortOrder = temp;
            
            this.setData(db, 'moveItem');
            return true;
        },

        searchMemos(q) {
            if (!q) return [];
            const db = this.getData();
            const results = [];
            const query = q.toLowerCase();
            const stripHtml = (html) => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || '';
            
            for (const memo of db.memos) {
                if (memo.isTrash) continue;
                
                const title = memo.title.toLowerCase();
                const content = stripHtml(memo.content).toLowerCase();
                const titleIndex = title.indexOf(query);
                const contentIndex = content.indexOf(query);
                
                if (titleIndex > -1 || contentIndex > -1) {
                    let snippet = '';
                    if (contentIndex > -1) {
                        const start = Math.max(0, contentIndex - 15);
                        const end = Math.min(content.length, contentIndex + query.length + 15);
                        snippet = this.escapeHTML(content.substring(start, end)).replace(
                            new RegExp(this.escapeHTML(q), 'gi'),
                            (match) => `<mark>${match}</mark>`
                        );
                    } else {
                        snippet = this.escapeHTML(stripHtml(memo.content).substring(0, 100));
                    }
                    results.push({ ...memo, snippet });
                }
            }
            return results;
        },

        exportData() {
            const d = this.getData();
            const b = new Blob([JSON.stringify(d, null, 2)], { type: 'application/json' });
            const u = URL.createObjectURL(b);
            const a = document.createElement('a');
            a.href = u;
            a.download = `memo-backup-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(u);
        },

        importData(f, cb) {
            const r = new FileReader();
            r.onload = (e) => {
                try {
                    const d = JSON.parse(e.target.result);
                    if (d && d.version && d.folders && d.memos && d.settings) {
                        this.setData(d, 'importData');
                        cb(true);
                    } else {
                        cb(false);
                    }
                } catch (err) {
                    cb(false);
                }
            };
            r.readAsText(f);
        },

        getActiveMemoId() {
            return this.getData()?.settings.activeMemoId;
        },

        setActiveMemoId(i) {
            const d = this.getData();
            if (d) {
                d.settings.activeMemoId = i;
                this.setData(d, 'setActiveMemoId');
            }
        },

        getActiveFolderId() {
            return this.getData()?.settings.activeFolderId;
        },

        setActiveFolderId(i) {
            const d = this.getData();
            if (d) {
                d.settings.activeFolderId = i;
                this.setData(d, 'setActiveFolderId');
            }
        },

        escapeHTML(s) {
            if (s === null || s === undefined) {
                return '';
            }
            return s.toString().replace(/[&<>"']/g, m => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[m]));
        },

        saveTimeout: null,

        scheduleSave(callback) {
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => {
                callback();
            }, 500);
        },

        flushPendingSave(callback) {
            clearTimeout(this.saveTimeout);
            callback();
        },
    };

    const uiManager = {
        elements: {},
        quillInstance: null,
        currentMemoId: null,
        currentFolderId: null,
        saveTimeout: null,
        pendingSaveForMemoId: null,
        isSearching: false,
        contextMenuTarget: null,
        copiedItem: null,

        init(quill) {
            this.quillInstance = quill;
            this.cacheElements();
            this.currentFolderId = dataManager.getActiveFolderId();
            this.addEventListeners();
            this.loadInitialMemo();
            this.render();
            
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    this.flushPendingSave();
                }
            });
            
            window.addEventListener('beforeunload', () => {
                this.flushPendingSave();
            });
        },

        cacheElements() {
            this.elements = {
                titleInput: document.querySelector('.app-header__title-input'),
                trashBtn: document.querySelector('#trash-btn'),
                searchInput: document.querySelector('.app-sidebar__search-input'),
                unifiedTreeContainer: document.querySelector('#unified-tree-container'),
                contextMenu: document.querySelector('#context-menu'),
                trashModalOverlay: document.querySelector('#trash-modal-overlay'),
                trashListContainer: document.querySelector('#trash-list-container'),
                trashModalCloseBtn: document.querySelector('#trash-modal-overlay .modal-close-btn'),
                emptyTrashBtn: document.querySelector('#empty-trash-btn'),
                settingsBtn: document.querySelector('#settings-btn'),
                settingsModalOverlay: document.querySelector('#settings-modal-overlay'),
                settingsModalCloseBtn: document.querySelector('#settings-modal-overlay .modal-close-btn'),
                editorFooter: document.querySelector('#editor-footer'),
                customDialogOverlay: document.querySelector('#custom-dialog-overlay'),
                dialogTitle: document.querySelector('#dialog-title'),
                dialogMessage: document.querySelector('#dialog-message'),
                dialogInput: document.querySelector('#dialog-input'),
                dialogOkBtn: document.querySelector('#dialog-ok-btn'),
                dialogCancelBtn: document.querySelector('#dialog-cancel-btn'),
            };
        },

        handleTyping() {
            this.scheduleSave();
        },

        scheduleSave() {
            dataManager.scheduleSave(() => {
                this.saveCurrentMemo();
            });
        },

        flushPendingSave() {
            dataManager.flushPendingSave(() => {
                this.saveCurrentMemo();
            });
        },

        showCustomDialog(title, message, type = 'confirm', defaultValue = '', callback = null) {
            this.elements.dialogTitle.textContent = title;
            this.elements.dialogMessage.textContent = message;
            
            if (type === 'prompt') {
                this.elements.dialogInput.style.display = 'block';
                this.elements.dialogInput.value = defaultValue;
                this.elements.dialogInput.focus();
            } else {
                this.elements.dialogInput.style.display = 'none';
            }
            
            this.elements.customDialogOverlay.classList.add('visible');
            
            const handleResponse = (confirmed) => {
                this.elements.customDialogOverlay.classList.remove('visible');
                if (callback) {
                    if (type === 'prompt') {
                        if (confirmed) {
                            const inputValue = this.elements.dialogInput.value;
                            callback(inputValue);
                        } else {
                            callback(null); // „Ç≠„É£„É≥„Çª„É´ÊôÇ„ÅØnull„ÇíËøî„Åô
                        }
                    } else {
                        callback(confirmed);
                    }
                }
            };
            
            const onOk = () => handleResponse(true);
            const onCancel = () => handleResponse(false);
            
            // Êó¢Â≠ò„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
            this.elements.dialogOkBtn.replaceWith(this.elements.dialogOkBtn.cloneNode(true));
            this.elements.dialogCancelBtn.replaceWith(this.elements.dialogCancelBtn.cloneNode(true));
            
            // Êñ∞„Åó„ÅÑÂèÇÁÖß„ÇíÂèñÂæó
            this.elements.dialogOkBtn = document.querySelector('#dialog-ok-btn');
            this.elements.dialogCancelBtn = document.querySelector('#dialog-cancel-btn');
            
            this.elements.dialogOkBtn.addEventListener('click', onOk);
            this.elements.dialogCancelBtn.addEventListener('click', onCancel);
            
            // Enter„Ç≠„Éº„Åß„ÅÆÁ¢∫ÂÆöÂØæÂøú
            const enterHandler = (e) => {
                if (e.key === 'Enter') {
                    onOk();
                    document.removeEventListener('keydown', enterHandler);
                }
            };
            document.addEventListener('keydown', enterHandler);
        },

        addEventListeners() {
            // ÂÆâÂÖ®„Å´„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
            const safeAddEventListener = (element, event, handler) => {
                if (element) {
                    element.addEventListener(event, handler);
                } else {
                    console.warn(`Element not found for event: ${event}`);
                }
            };

            safeAddEventListener(this.elements.titleInput, 'keyup', () => this.handleTyping());
            safeAddEventListener(this.elements.titleInput, 'input', () => this.handleTyping());
            safeAddEventListener(this.elements.titleInput, 'blur', () => this.flushPendingSave());
            
            this.quillInstance.on('text-change', () => { this.handleTyping(); });
            this.quillInstance.on('selection-change', (range) => {
                if (range == null) this.flushPendingSave();
            });
            
            safeAddEventListener(this.elements.unifiedTreeContainer, 'click', (e) => { 
                this.flushPendingSave(); 
                this.handleTreeClick(e); 
            });
            
            safeAddEventListener(this.elements.unifiedTreeContainer, 'contextmenu', (e) => {
                if (e.target.closest('.tree-item')) {
                    this.handleTreeContextMenu(e);
                } else if (e.target === this.elements.unifiedTreeContainer) {
                    e.preventDefault();
                    this.showRootContextMenu(e.clientX, e.clientY);
                }
            });
            
            safeAddEventListener(this.elements.searchInput, 'input', (e) => this.handleSearch(e));
            
            safeAddEventListener(this.elements.trashBtn, 'click', () => this.showTrashModal());
            safeAddEventListener(this.elements.trashModalCloseBtn, 'click', () => this.hideTrashModal());
            safeAddEventListener(this.elements.trashModalOverlay, 'click', (e) => { 
                if(e.target === this.elements.trashModalOverlay) this.hideTrashModal(); 
            });
            
            safeAddEventListener(this.elements.trashListContainer, 'click', (e) => this.handleTrashAction(e));
            safeAddEventListener(this.elements.emptyTrashBtn, 'click', () => this.handleEmptyTrash());
            
            safeAddEventListener(this.elements.settingsBtn, 'click', () => this.showSettingsModal());
            safeAddEventListener(this.elements.settingsModalCloseBtn, 'click', () => this.hideSettingsModal());
            safeAddEventListener(this.elements.settingsModalOverlay, 'click', (e) => { 
                if(e.target === this.elements.settingsModalOverlay) this.hideSettingsModal(); 
            });
            
            // Ë®≠ÂÆö„É¢„Éº„ÉÄ„É´ÂÜÖ„ÅÆ„Éú„Çø„É≥
            document.addEventListener('click', (e) => {
                if (e.target.id === 'export-btn-settings') {
                    dataManager.exportData();
                }
            });
            
            document.addEventListener('change', (e) => {
                if (e.target.id === 'import-input-settings') {
                    this.handleImport(e);
                }
            });
            
            safeAddEventListener(this.elements.contextMenu, 'click', (e) => this.handleContextMenuClick(e));
            document.addEventListener('click', () => this.hideContextMenu());
        },

        render() {
            console.log("//-D- render called");
            this.renderUnifiedTree();
        },

        renderUnifiedTree() {
            const db = dataManager.getData();
            let html = '';
            
            const rootMemos = this.getSortedMemos(db, null);
            rootMemos.forEach(memo => {
                html += this.createMemoHTML(memo, 0);
            });
            
            html += this.buildTree(db, null, 0);
            
            this.elements.unifiedTreeContainer.innerHTML = html;
        },

        buildTree(db, parentId, level) {
            if (level >= 3) return '';
            let html = '';
            
            const folders = this.getSortedFolders(db, parentId);
            folders.forEach(folder => {
                html += this.createFolderHTML(folder, level);
                
                if (!folder.isCollapsed) {
                    const memos = this.getSortedMemos(db, folder.id);
                    memos.forEach(memo => {
                        html += this.createMemoHTML(memo, level + 1);
                    });
                    
                    html += this.buildTree(db, folder.id, level + 1);
                }
            });
            
            return html;
        },

        createFolderHTML(folder, level) {
            const isCollapsed = folder.isCollapsed || false;
            return `
                <div class="tree-item folder ${folder.id === this.currentFolderId ? 'active' : ''}" 
                     data-id="${folder.id}" data-type="folder" data-level="${level}">
                    <div class="folder-icon-name">
                        <span class="folder-toggle">${isCollapsed ? '+' : '-'}</span>
                        <span class="folder-icon">üìÅ ${dataManager.escapeHTML(folder.name)}</span>
                    </div>
                    <div class="sort-buttons">
                        <button class="sort-btn" data-direction="up" title="‰∏ä„Å´ÁßªÂãï">‚ñ≤</button>
                        <button class="sort-btn" data-direction="down" title="‰∏ã„Å´ÁßªÂãï">‚ñº</button>
                    </div>
                </div>
            `;
        },

        createMemoHTML(memo, level) {
            const isActive = memo.id === this.currentMemoId;
            let snippet = '';
            
            if (this.isSearching && memo.snippet) {
                snippet = `<div class="tree-item__snippet">${memo.snippet}</div>`;
            }
            
            return `
                <div class="tree-item memo ${isActive ? 'active' : ''}" 
                     data-id="${memo.id}" data-type="memo" data-level="${level}">
                    <div>
                        <span>${dataManager.escapeHTML(memo.title)}</span>
                        ${snippet}
                    </div>
                    <div class="sort-buttons">
                        <button class="sort-btn" data-direction="up" title="‰∏ä„Å´ÁßªÂãï">‚ñ≤</button>
                        <button class="sort-btn" data-direction="down" title="‰∏ã„Å´ÁßªÂãï">‚ñº</button>
                    </div>
                </div>
            `;
        },

        getSortedFolders(db, parentId) {
            const folders = db.folders.filter(f => f.parentId === parentId && !f.isTrash);
            return folders.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        },

        getSortedMemos(db, folderId) {
            const memos = db.memos.filter(m => m.folderId === folderId && !m.isTrash);
            return memos.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
        },

        handleTreeClick(e) {
            const item = e.target.closest('.tree-item');
            if (!item) return;
            
            const id = item.dataset.id;
            const type = item.dataset.type;
            
            if (e.target.classList.contains('sort-btn')) {
                e.stopPropagation();
                const direction = e.target.dataset.direction;
                const parentId = type === 'folder' ? 
                    dataManager.getData().folders.find(f => f.id === id)?.parentId || null :
                    dataManager.getData().memos.find(m => m.id === id)?.folderId || null;
                
                if (dataManager.moveItem(id, type, direction, parentId)) {
                    this.render();
                }
                return;
            }
            
            if (type === 'folder') {
                if (e.target.classList.contains('folder-toggle') || e.target.classList.contains('folder-icon')) {
                    dataManager.toggleFolderCollapse(id);
                    this.render();
                } else {
                    this.selectFolder(id);
                }
            } else if (type === 'memo') {
                this.selectMemo(id);
            }
        },

        handleTreeContextMenu(e) {
            e.preventDefault();
            const item = e.target.closest('.tree-item');
            if (!item) return;
            
            this.contextMenuTarget = {
                id: item.dataset.id,
                type: item.dataset.type
            };
            
            this.showContextMenu(e.clientX, e.clientY);
        },

        showRootContextMenu(x, y) {
            this.contextMenuTarget = {
                id: this.currentFolderId,
                type: 'root'
            };
            this.showContextMenu(x, y);
        },

        showContextMenu(x, y) {
            const menu = this.elements.contextMenu;
            const menuItems = menu.querySelectorAll('.context-menu-item');
            
            menuItems.forEach(item => {
                const action = item.dataset.action;
                item.classList.remove('disabled');
                
                if (action === 'paste' && !this.copiedItem) {
                    item.classList.add('disabled');
                }
                
                if (this.contextMenuTarget.type === 'root') {
                    if (['rename', 'copy', 'delete'].includes(action)) {
                        item.classList.add('disabled');
                    }
                }
            });
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        },

        hideContextMenu() {
            this.elements.contextMenu.style.display = 'none';
        },

        handleContextMenuClick(e) {
            const action = e.target.dataset.action;
            if (!action || e.target.classList.contains('disabled')) return;
            
            this.hideContextMenu();
            
            const target = this.contextMenuTarget;
            if (!target) return;
            
            switch (action) {
                case 'newMemo':
                    const targetFolderId = target.type === 'folder' ? target.id : target.id;
                    const newMemo = dataManager.createMemo(targetFolderId);
                    this.selectMemo(newMemo.id);
                    this.render();
                    break;
                    
                case 'newFolder':
                    this.showCustomDialog(
                        'Êñ∞„Åó„ÅÑ„Éï„Ç©„É´„ÉÄ',
                        '„Éï„Ç©„É´„ÉÄÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö',
                        'prompt',
                        '',
                        (folderName) => {
                            if (folderName && folderName.trim()) {
                                const parentId = target.type === 'folder' ? target.id : target.id;
                                dataManager.createFolder(folderName.trim(), parentId);
                                this.render();
                            }
                        }
                    );
                    break;
                    
                case 'rename':
                    if (target.type === 'memo') {
                        const memo = dataManager.getData().memos.find(m => m.id === target.id);
                        if (memo) {
                            this.showCustomDialog(
                                '„É°„É¢„ÅÆÂêçÂâç„ÇíÂ§âÊõ¥',
                                'Êñ∞„Åó„ÅÑÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö',
                                'prompt',
                                memo.title,
                                (newTitle) => {
                                    if (newTitle && newTitle.trim()) {
                                        dataManager.renameMemo(target.id, newTitle.trim());
                                        if (this.currentMemoId === target.id) {
                                            this.elements.titleInput.value = newTitle.trim();
                                        }
                                        this.render();
                                    }
                                }
                            );
                        }
                    } else if (target.type === 'folder') {
                        const folder = dataManager.getData().folders.find(f => f.id === target.id);
                        if (folder) {
                            this.showCustomDialog(
                                '„Éï„Ç©„É´„ÉÄ„ÅÆÂêçÂâç„ÇíÂ§âÊõ¥',
                                'Êñ∞„Åó„ÅÑÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö',
                                'prompt',
                                folder.name,
                                (newName) => {
                                    if (newName && newName.trim()) {
                                        dataManager.renameFolder(target.id, newName.trim());
                                        this.render();
                                    }
                                }
                            );
                        }
                    }
                    break;
                    
                case 'copy':
                    this.copiedItem = dataManager.copyItem(target.id, target.type);
                    break;
                    
                case 'paste':
                    if (this.copiedItem) {
                        const targetFolderId = target.type === 'folder' ? target.id : target.id;
                        dataManager.pasteItem(this.copiedItem, targetFolderId);
                        this.render();
                    }
                    break;
                    
                case 'delete':
                    const itemName = target.type === 'memo' ? 
                        dataManager.getData().memos.find(m => m.id === target.id)?.title :
                        dataManager.getData().folders.find(f => f.id === target.id)?.name;
                    
                    this.showCustomDialog(
                        'ÂâäÈô§„ÅÆÁ¢∫Ë™ç',
                        `„Äå${itemName}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`,
                        'confirm',
                        '',
                        (confirmed) => {
                            if (confirmed) {
                                if (target.type === 'memo') {
                                    dataManager.deleteMemo(target.id);
                                    if (this.currentMemoId === target.id) {
                                        this.loadInitialMemo();
                                    }
                                } else if (target.type === 'folder') {
                                    dataManager.deleteFolder(target.id);
                                }
                                this.render();
                            }
                        }
                    );
                    break;
            }
        },

        selectMemo(id) {
            if (this.currentMemoId === id) return;
            
            this.flushPendingSave();
            
            const memo = dataManager.getData().memos.find(m => m.id === id && !m.isTrash);
            if (!memo) {
                this.loadInitialMemo();
                return;
            }
            
            this.currentMemoId = id;
            dataManager.setActiveMemoId(id);
            
            this.elements.titleInput.value = memo.title;
            this.quillInstance.root.innerHTML = memo.content;
            
            this.updateEditorFooter(memo);
            this.render();
        },

        selectFolder(id) {
            this.currentFolderId = id;
            dataManager.setActiveFolderId(id);
            this.render();
        },

        loadInitialMemo() {
            const db = dataManager.getData();
            const activeMemoId = dataManager.getActiveMemoId();
            
            let targetMemo = null;
            
            if (activeMemoId) {
                targetMemo = db.memos.find(m => m.id === activeMemoId && !m.isTrash);
            }
            
            if (!targetMemo) {
                const availableMemos = db.memos.filter(m => !m.isTrash);
                if (availableMemos.length > 0) {
                    targetMemo = availableMemos.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))[0];
                }
            }
            
            if (targetMemo) {
                this.selectMemo(targetMemo.id);
            } else {
                this.currentMemoId = null;
                dataManager.setActiveMemoId(null);
                this.elements.titleInput.value = '';
                this.quillInstance.root.innerHTML = '<p></p>';
                this.elements.editorFooter.textContent = '';
            }
        },

        saveCurrentMemo() {
            if (!this.currentMemoId) return;
            
            const title = this.elements.titleInput.value || 'ÁÑ°È°å';
            const content = this.quillInstance.root.innerHTML;
            
            const updatedMemo = dataManager.updateMemo(this.currentMemoId, { title, content });
            if (updatedMemo) {
                this.updateEditorFooter(updatedMemo);
                this.render();
            }
        },

        updateEditorFooter(memo) {
            if (!memo) return;
            const updatedAt = new Date(memo.updatedAt);
            this.elements.editorFooter.textContent = dataManager.formatDateTime(updatedAt);
        },

        handleSearch(e) {
            const query = e.target.value.trim();
            
            if (query) {
                this.isSearching = true;
                const results = dataManager.searchMemos(query);
                this.renderSearchResults(results);
            } else {
                this.isSearching = false;
                this.render();
            }
        },

        renderSearchResults(results) {
            let html = '';
            results.forEach(memo => {
                html += this.createMemoHTML(memo, 0);
            });
            
            if (html === '') {
                html = '<div style="padding: 16px; text-align: center; color: #666;">Ê§úÁ¥¢ÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
            }
            
            this.elements.unifiedTreeContainer.innerHTML = html;
        },

        showTrashModal() {
            this.elements.trashModalOverlay.classList.add('visible');
            this.renderTrashList();
        },

        hideTrashModal() {
            this.elements.trashModalOverlay.classList.remove('visible');
        },

        renderTrashList() {
            const { memos, folders } = dataManager.getTrashedItems();
            let html = '';
            
            [...folders, ...memos].forEach(item => {
                const type = item.folderId !== undefined ? 'memo' : 'folder';
                const name = type === 'memo' ? item.title : item.name;
                html += `
                    <div class="list-item" data-id="${item.id}" data-type="${type}">
                        <span class="list-item__name ${type}">${dataManager.escapeHTML(name)}</span>
                        <div>
                            <button class="restore-btn">Âæ©ÂÖÉ</button>
                            <button class="delete-perm-btn">ÂÆåÂÖ®„Å´ÂâäÈô§</button>
                        </div>
                    </div>
                `;
            });
            
            this.elements.trashListContainer.innerHTML = html || "<p>„Ç¥„ÉüÁÆ±„ÅØÁ©∫„Åß„Åô„ÄÇ</p>";
        },

        handleTrashAction(e) {
            const item = e.target.closest('.list-item');
            if (!item) return;
            
            const id = item.dataset.id;
            const type = item.dataset.type;
            
            if (e.target.classList.contains('restore-btn')) {
                dataManager.restoreItem(id, type);
            } else if (e.target.classList.contains('delete-perm-btn')) {
                if (confirm('„Åì„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    dataManager.deleteItemPermanently(id, type);
                }
            }
            
            this.renderTrashList();
            this.render();
        },

        handleEmptyTrash() {
            this.elements.customDialogOverlay.classList.add('position-top-right');
            this.showCustomDialog(
                'Á¢∫Ë™ç',
                '„Ç¥„ÉüÁÆ±„ÇíÂÆåÂÖ®„Å´Á©∫„Å´„Åó„Åæ„Åô„ÅãÔºü\n„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ',
                'confirm',
                '',
                (confirmed) => {
                    this.elements.customDialogOverlay.classList.remove('position-top-right');
                    if (confirmed) {
                        dataManager.emptyTrash();
                        this.renderTrashList();
                        this.render();
                    }
                }
            );
        },

        handleImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            dataManager.importData(file, (success) => {
                if (success) {
                    alert('„Ç§„É≥„Éù„Éº„Éà„Å´ÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ');
                    dataManager.loadDataFromStorage();
                    this.loadInitialMemo();
                } else {
                    alert('„Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éï„Ç°„Ç§„É´„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                }
                e.target.value = '';
            });
        },

        showSettingsModal() {
            this.elements.settingsModalOverlay.classList.add('visible');
        },

        hideSettingsModal() {
            this.elements.settingsModalOverlay.classList.remove('visible');
        }
    };

    const quill = new Quill('#editor-container', {
        theme: 'snow',
        modules: {
            toolbar: [
                ['bold', 'italic'],
                [{ 'color': [] }, { 'size': ['small', false, 'large', 'huge'] }],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                ['link', 'blockquote']
            ]
        }
    });

    dataManager.init();
    uiManager.init(quill);
});
    </script>
</body>
</html>
