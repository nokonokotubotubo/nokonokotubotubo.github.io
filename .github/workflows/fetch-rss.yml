name: Fetch RSS Feeds and Deploy

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  fetch-rss:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Create RSS directory
      run: |
        mkdir -p rss
        echo "âœ… rssãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¾ã—ãŸ"

    - name: Fetch Qiita RSS Feed
      uses: Promptly-Technologies-LLC/rss-fetch-action@v2
      with:
        feed_url: 'https://qiita.com/tags/%E7%94%9F%E6%88%90ai/feed'
        file_path: './temp-qiita-feed.json'

    - name: Fetch Zenn RSS Feed
      uses: Promptly-Technologies-LLC/rss-fetch-action@v2
      with:
        feed_url: 'https://zenn.dev/topics/%E7%94%9F%E6%88%90ai/feed'
        file_path: './temp-zenn-feed.json'

    - name: Fetch CNET RSS Feed
      uses: Promptly-Technologies-LLC/rss-fetch-action@v2
      with:
        feed_url: 'http://feeds.japan.cnet.com/cnet/rss'
        file_path: './temp-cnet-feed.json'

    - name: Merge RSS Feeds and Generate JSON
      run: |
        node << 'EOF'
        const fs = require('fs');
        const path = require('path');
        
        console.log('ğŸš€ RSSçµ±åˆå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...');
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰å®šç¾©
        const feeds = [
          { 
            name: 'Qiita', 
            file: './temp-qiita-feed.json', 
            color: '#55C500',
            description: 'Qiita ç”ŸæˆAIè¨˜äº‹'
          },
          { 
            name: 'Zenn', 
            file: './temp-zenn-feed.json', 
            color: '#3EA8FF',
            description: 'Zenn ç”ŸæˆAIè¨˜äº‹'
          },
          { 
            name: 'CNET', 
            file: './temp-cnet-feed.json', 
            color: '#C41E3A',
            description: 'CNET Japan ãƒ‹ãƒ¥ãƒ¼ã‚¹'
          }
        ];
        
        let allEntries = [];
        let processedFeeds = [];
        
        // å„ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å‡¦ç†
        feeds.forEach(feed => {
          try {
            console.log(`ğŸ“– ${feed.name} ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å‡¦ç†ä¸­...`);
            
            if (!fs.existsSync(feed.file)) {
              console.log(`âš ï¸  ${feed.file} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
              return;
            }
            
            const rawData = fs.readFileSync(feed.file, 'utf8');
            const data = JSON.parse(rawData);
            
            if (data.entries && Array.isArray(data.entries)) {
              // æœ€æ–°5ä»¶ã‚’å–å¾—ã—ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
              const feedEntries = data.entries.slice(0, 5).map(entry => ({
                ...entry,
                source: feed.name,
                sourceColor: feed.color,
                sourceFeed: feed.name.toLowerCase(),
                // æ—¥ä»˜æ­£è¦åŒ–
                published: entry.published || entry.pubDate || new Date().toISOString(),
                // ã‚µãƒãƒªãƒ¼ç”Ÿæˆ
                summary: (entry.description || entry.summary || '').replace(/<[^>]*>/g, '').substring(0, 150),
                // ã‚µãƒ ãƒã‚¤ãƒ«æŠ½å‡ºè©¦è¡Œ
                thumbnail: extractThumbnail(entry)
              }));
              
              allEntries = allEntries.concat(feedEntries);
              processedFeeds.push({
                name: feed.name,
                color: feed.color,
                description: feed.description,
                count: feedEntries.length
              });
              
              console.log(`âœ… ${feed.name}: ${feedEntries.length}ä»¶ã®è¨˜äº‹ã‚’è¿½åŠ `);
            } else {
              console.log(`âš ï¸  ${feed.name}: entriesãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹é…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“`);
            }
            
          } catch (error) {
            console.error(`âŒ ${feed.name} å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error.message);
          }
        });
        
        // ã‚µãƒ ãƒã‚¤ãƒ«æŠ½å‡ºé–¢æ•°ï¼ˆ401ã‚¨ãƒ©ãƒ¼å¯¾ç­–ç‰ˆï¼‰
        function extractThumbnail(entry) {
          let thumbnailUrl = null;
          
          // 1. enclosures ã‹ã‚‰ç”»åƒã‚’æŠ½å‡º
          if (entry.enclosures && Array.isArray(entry.enclosures)) {
            const imageEnclosure = entry.enclosures.find(enc => 
              enc.type && 
              enc.type.startsWith('image/') && 
              (enc.url || enc.href)
            );
            if (imageEnclosure) {
              thumbnailUrl = imageEnclosure.url || imageEnclosure.href;
            }
          }
          
          // 2. media:content ã‹ã‚‰æŠ½å‡º
          if (!thumbnailUrl && entry['media:content']) {
            const mediaContent = Array.isArray(entry['media:content']) 
              ? entry['media:content'] 
              : [entry['media:content']];
            
            for (const media of mediaContent) {
              if (media.url && (media.medium === 'image' || (media.type && media.type.startsWith('image/')))) {
                thumbnailUrl = media.url;
                break;
              }
            }
          }
          
          // 3. media:thumbnail ã‹ã‚‰æŠ½å‡º
          if (!thumbnailUrl && entry['media:thumbnail']) {
            thumbnailUrl = typeof entry['media:thumbnail'] === 'string' 
              ? entry['media:thumbnail'] 
              : entry['media:thumbnail'].url;
          }
          
          // 4. descriptionå†…ã®imgè¦ç´ ã‹ã‚‰æŠ½å‡º
          if (!thumbnailUrl && entry.description) {
            const imgMatch = entry.description.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/i);
            if (imgMatch && imgMatch[1]) {
              thumbnailUrl = imgMatch[1];
            }
          }
          
          // 5. contentè¦ç´ ã‹ã‚‰imgæŠ½å‡º
          if (!thumbnailUrl && entry.content) {
            const contentText = typeof entry.content === 'object' ? 
              (entry.content.value || entry.content['#text'] || '') : 
              entry.content;
            const imgMatch = contentText.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/i);
            if (imgMatch && imgMatch[1]) {
              thumbnailUrl = imgMatch[1];
            }
          }
          
          // 6. URLå¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ401ã‚¨ãƒ©ãƒ¼å¯¾ç­–ï¼‰
          if (thumbnailUrl) {
            try {
              const url = new URL(thumbnailUrl);
              
              // HTTPSã§ãªã„å ´åˆã¯é™¤å¤–
              if (url.protocol !== 'https:') {
                console.log(`âš ï¸  HTTPç”»åƒURLã‚’ã‚¹ã‚­ãƒƒãƒ—: ${thumbnailUrl}`);
                return null;
              }
              
              // ã‚¢ã‚¯ã‚»ã‚¹åˆ¶é™ãŒã‹ã‹ã‚Šã‚„ã™ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é™¤å¤–
              const restrictedPatterns = [
                'ogp.png',
                '/admin/',
                '/private/',
                '/protected/',
                'basic-auth',
                'unauthorized'
              ];
              
              if (restrictedPatterns.some(pattern => thumbnailUrl.toLowerCase().includes(pattern))) {
                console.log(`âš ï¸  åˆ¶é™ãƒ‘ã‚¹ã®ç”»åƒã‚’ã‚¹ã‚­ãƒƒãƒ—: ${thumbnailUrl}`);
                return null;
              }
              
              return thumbnailUrl;
              
            } catch (e) {
              console.log(`âš ï¸  ç„¡åŠ¹ãªURL: ${thumbnailUrl}`);
              return null;
            }
          }
          
          return null;
        }
        
        // æ—¥ä»˜é †ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
        allEntries.sort((a, b) => new Date(b.published) - new Date(a.published));
        
        // æœ€çµ‚çš„ã«15ä»¶ã«åˆ¶é™
        allEntries = allEntries.slice(0, 15);
        
        // çµ±åˆçµæœã®JSONã‚’ç”Ÿæˆ
        const result = {
          title: 'RSS Reader - ç”ŸæˆAIè¨˜äº‹ãƒ•ã‚£ãƒ¼ãƒ‰',
          description: 'æœ€æ–°ã®ç”ŸæˆAIé–¢é€£è¨˜äº‹ã‚’ã¾ã¨ã‚ã¦é…ä¿¡',
          updated: new Date().toISOString(),
          totalEntries: allEntries.length,
          feeds: processedFeeds,
          entries: allEntries
        };
        
        // JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡ºåŠ›
        const outputPath = './rss/feeds.json';
        fs.writeFileSync(outputPath, JSON.stringify(result, null, 2), 'utf8');
        
        console.log(`ğŸ‰ çµ±åˆå®Œäº†: ${allEntries.length}ä»¶ã®è¨˜äº‹ã‚’ ${outputPath} ã«å‡ºåŠ›ã—ã¾ã—ãŸ`);
        
        // ã‚µãƒãƒªãƒ¼è¡¨ç¤º
        processedFeeds.forEach(feed => {
          console.log(`   ğŸ“° ${feed.name}: ${feed.count}ä»¶`);
        });
        
        // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
        feeds.forEach(feed => {
          if (fs.existsSync(feed.file)) {
            fs.unlinkSync(feed.file);
            console.log(`ğŸ—‘ï¸  ${feed.file} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
          }
        });
        EOF

    - name: Get current date
      id: date
      run: echo "date=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Commit and push changes
      uses: stefanzweifel/git-auto-commit-action@v4
      with:
        commit_message: 'ğŸ¤– RSS feeds updated - ${{ steps.date.outputs.date }}'
        file_pattern: 'rss/feeds.json'
        commit_user_name: 'RSS Bot'
        commit_user_email: 'rss-bot@github-actions.local'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    needs: fetch-rss
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: main

    - name: Setup Pages
      uses: actions/configure-pages@v5

    - name: Upload artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: './'

    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4

    - name: Display deployment URL
      run: |
        echo "ğŸš€ ã‚µã‚¤ãƒˆãŒãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã¾ã—ãŸ!"
        echo "ğŸ“± ã‚¢ã‚¯ã‚»ã‚¹URL: ${{ steps.deployment.outputs.page_url }}rss/"
        echo "ğŸ“Š GitHub Pagesè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„"
