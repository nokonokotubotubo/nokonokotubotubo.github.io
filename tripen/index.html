<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>とりっぺんちゃん - 旅行予定調整サイト</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<!-- Leafletライブラリ（OpenStreetMap API用）-->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
:root{--primary:#87CEEB;--secondary:#B0E0E6;--accent:#4682B4;--text:#2F4F4F;--bg:#F0F8FF;--time-bg:#E6F3FF;--transition:all 0.3s ease;--radius:15px;--shadow:0 2px 10px rgba(0,0,0,0.1)}
*{box-sizing:border-box}
html,body{height:100%;overflow:hidden;margin:0;padding:0}
body{background:var(--bg);color:var(--text);font-family:system-ui,sans-serif;display:flex;flex-direction:column}
#app{height:100vh;display:flex;flex-direction:column;overflow:hidden}
.header{background:linear-gradient(135deg,var(--primary),var(--secondary));color:white;padding:8px 0;text-align:center;box-shadow:var(--shadow);flex-shrink:0}
.penguin-icon{font-size:2rem;margin-right:10px}
.desktop-ui,.mobile-ui{flex:1;display:flex;flex-direction:column;overflow:hidden}
.day-tabs-container{overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--secondary) transparent;flex-shrink:0}
.day-tabs{background:white;border-radius:var(--radius) var(--radius) 0 0;margin:10px 0 0 0;box-shadow:var(--shadow);display:flex;min-width:max-content}
.day-tabs .nav-item{transition:var(--transition);flex-shrink:0;position:relative}
.day-tabs .nav-link{border:none;color:var(--text);padding:12px 20px;line-height: 1.2;border-radius:var(--radius) var(--radius) 0 0;white-space:nowrap;text-align:center;min-width:120px;transition:var(--transition);position:relative;display:block}
.day-tabs .nav-link.active{background:var(--primary);color:white;box-shadow:var(--shadow)}
.day-tabs .nav-link:hover{background:var(--secondary);color:white}
.delete-day-btn{position:absolute;top:5px;right:5px;width:20px;height:20px;border-radius:50%;background:rgba(255,99,99,0.8);color:white;border:none;font-size:0.7rem;display:none;align-items:center;justify-content:center;cursor:pointer;transition:var(--transition)}
.delete-day-btn:hover{background:rgba(255,99,99,1);transform:scale(1.1)}
.day-tabs .nav-link:hover .delete-day-btn{display:flex}
.mobile-day-selector{background:white;padding:12px 0;box-shadow:var(--shadow);flex-shrink:0;position:relative}
.mobile-scroll-container{position:relative;padding:0 50px}
.mobile-day-buttons{display:flex;gap:10px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--secondary) transparent;padding:0 15px 10px 15px}
.mobile-day-btn{min-width:100px;height:60px;border:2px solid var(--secondary);background:white;border-radius:var(--radius);display:flex;flex-direction:column;align-items:center;justify-content:center;font:bold 0.9rem/1 sans-serif;color:var(--text);transition:var(--transition);flex-shrink:0;-webkit-tap-highlight-color:transparent;user-select:none;touch-action:manipulation}
.mobile-day-btn.active{background:var(--primary);color:white;border-color:var(--primary)}
.mobile-day-btn:active{transform:scale(0.95)}
.mobile-scroll-nav{position:absolute;top:50%;transform:translateY(-50%);width:40px;height:40px;border-radius:50%;background:rgba(255,255,255,0.9);border:2px solid var(--secondary);color:var(--accent);font-size:1rem;cursor:pointer;transition:var(--transition);z-index:10;display:flex;align-items:center;justify-content:center;box-shadow:var(--shadow)}
.mobile-scroll-nav:active{transform:translateY(-50%) scale(0.9)}
.mobile-scroll-nav.left{left:5px}
.mobile-scroll-nav.right{right:5px}
.mobile-scroll-nav.disabled{opacity:0.3;pointer-events:none}
.mobile-popup-menu{position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:2000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;transition:var(--transition);-webkit-tap-highlight-color:transparent}
.mobile-popup-menu.show{opacity:1;visibility:visible}
.mobile-popup-content{background:white;border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,0.3);max-width:300px;width:90%;text-align:center}
.mobile-popup-title{font:bold 1.2rem/1 sans-serif;color:var(--accent);margin-bottom:20px}
.mobile-popup-buttons{display:flex;flex-direction:column;gap:15px}
.mobile-popup-btn{padding:15px 20px;border:none;border-radius:var(--radius);font:bold 1rem/1 sans-serif;cursor:pointer;transition:var(--transition);display:flex;align-items:center;justify-content:center;gap:10px;-webkit-tap-highlight-color:transparent;touch-action:manipulation}
.mobile-popup-btn.primary{background:var(--primary);color:white}
.mobile-popup-btn.success{background:#28a745;color:white}
.mobile-popup-btn.danger{background:#dc3545;color:white}
.mobile-popup-btn.secondary{background:#6c757d;color:white}
.mobile-popup-btn:active{transform:scale(0.95)}
.mobile-fab{position:fixed;bottom:20px;right:20px;width:60px;height:60px;border-radius:50%;background:var(--accent);border:none;color:white;font-size:1.5rem;box-shadow:0 4px 15px rgba(0,0,0,0.3);transition:var(--transition);z-index:1000;-webkit-tap-highlight-color:transparent}
.mobile-fab:active{transform:scale(0.9)}
.timeline-container{background:white;border-radius:0 0 var(--radius) var(--radius);margin:0;box-shadow:0 4px 15px rgba(0,0,0,0.1);flex:1;display:flex;flex-direction:column;overflow:hidden}
.timeline-header{background:var(--secondary);padding:8px 20px;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.timeline-header h5{font-size:1rem;margin:0;line-height:1.2}
.timeline-header h5 small{font-size:0.85rem;margin-left:8px}
.timeline-content{flex:1;overflow:hidden}
.timeline-scroll-container{height:100%;display:flex;overflow-y:auto;overflow-x:hidden}
.time-axis{width:80px;background:var(--time-bg);border-right:2px solid var(--secondary);flex-shrink:0;height:1200px}
.time-slot{height:60px;display:flex;align-items:center;justify-content:center;font:bold 0.9rem/1 sans-serif;color:var(--text);border-bottom:1px solid #e0e0e0}
.schedule-area{flex:1;position:relative;height:1200px}
.schedule-grid{position:absolute;inset:0;height:1200px}
.grid-line{height:60px;border-bottom:1px solid #e0e0e0;position:relative}
.grid-line:nth-child(odd){background:rgba(135,206,235,0.05)}
.quarter-line{position:absolute;left:0;right:0;height:1px;background:#f0f0f0}
.quarter-line:nth-child(1){top:15px}
.quarter-line:nth-child(2){top:30px}
.quarter-line:nth-child(3){top:45px}
.event-block{position:absolute;left:10px;right:10px;background:var(--primary);color:white;border-radius:8px;padding:8px 12px 8px 25px;box-shadow:0 2px 8px rgba(0,0,0,0.2);border:2px solid transparent;transition:var(--transition);z-index:10;user-select:none;-webkit-tap-highlight-color:transparent;min-height:35px;display:flex;align-items:center}
.event-block:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);border-color:var(--accent)}
.event-block.edit-mode{border-color:#FFD700;box-shadow:0 0 0 3px rgba(255,215,0,0.3);cursor:grab}
.event-block.edit-mode:active{cursor:grabbing}
.event-block.ready-to-move{border-color:#4CAF50;box-shadow:0 0 0 3px rgba(76,175,80,0.4);transform:scale(1.05);background:linear-gradient(45deg,rgba(76,175,80,0.1),transparent,rgba(76,175,80,0.1));animation:readyToPulse 1.5s infinite ease-in-out}
@keyframes readyToPulse{0%,100%{box-shadow:0 0 0 3px rgba(76,175,80,0.4)}50%{box-shadow:0 0 0 6px rgba(76,175,80,0.2)}}
.event-block.ready-to-move::before{content:"↕";position:absolute;top:50%;right:8px;transform:translateY(-50%);font-size:1.2rem;color:#4CAF50;font-weight:bold;z-index:25;animation:bounceIcon 1s infinite ease-in-out}
@keyframes bounceIcon{0%,100%{transform:translateY(-50%) scale(1)}50%{transform:translateY(-50%) scale(1.2)}}
.event-block.dragging{z-index:1000;opacity:0.8;transform:scale(1.02)}
.event-block.dragging .event-actions{display:none!important}
.event-block.layered{/* 動的にz-indexが設定される */}
.event-content-inline{font-size:0.9rem;line-height:1.2;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;font-weight:bold}
.event-title,.event-time,.event-description{display:none}
.event-category-travel{background:#FF6B6B}
.event-category-food{background:#4ECDC4}
.event-category-sightseeing{background:#45B7D1}
.event-category-accommodation{background:#96CEB4}
.event-category-custom{background:#FECA57}
.event-actions{position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);display:flex;gap:5px;z-index:20}
.event-action-btn{width:30px;height:30px;border-radius:8px;border:none;color:white;font-size:0.8rem;cursor:pointer;transition:var(--transition);display:flex;align-items:center;justify-content:center;box-shadow:0 2px 6px rgba(0,0,0,0.3);touch-action:manipulation;-webkit-tap-highlight-color:transparent}
.event-action-btn.cut{background:#FF6B6B;border:2px solid #fff}
.event-action-btn.cut:hover{background:#FF5252;transform:scale(1.1)}
.context-menu{position:fixed;background:white;border:1px solid #ddd;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.2);z-index:2000;opacity:0;visibility:hidden;transform:scale(0.8);transition:var(--transition);min-width:150px}
.context-menu.show{opacity:1;visibility:visible;transform:scale(1)}
.context-menu-item{padding:12px 16px;cursor:pointer;border-bottom:1px solid #eee;transition:var(--transition);display:flex;align-items:center;gap:8px}
.context-menu-item:last-child{border-bottom:none}
.context-menu-item:hover{background:#f5f5f5}
.context-menu-item.paste{color:#4CAF50}
.context-menu-item.paste:hover{background:#e8f5e8}
.context-menu-item.add-event{color:#4CAF50}
.context-menu-item.add-event:hover{background:#e8f5e8}
.context-menu-item.disabled{color:#ccc;cursor:not-allowed}
.context-menu-item.disabled:hover{background:transparent}
.resize-handle{position:absolute;left:0;right:0;height:10px;background:rgba(255,215,0,0.8);opacity:0;transition:var(--transition);cursor:ns-resize}
.resize-handle.top{top:0;border-radius:8px 8px 0 0}
.resize-handle.bottom{bottom:0;border-radius:0 0 8px 8px}
.event-block.edit-mode .resize-handle{opacity:1}
.modal-content{border-radius:var(--radius);border:none;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
.modal-header{background:var(--primary);color:white;border-radius:var(--radius) var(--radius) 0 0}
.btn-primary{background:var(--accent);border:none;border-radius:20px;padding:8px 20px;transition:var(--transition)}
.btn-primary:hover{background:var(--text);transform:translateY(-2px)}
.form-control{border-radius:10px;border:2px solid #e0e0e0;transition:var(--transition)}
.form-control:focus{border-color:var(--primary);box-shadow:0 0 0 0.2rem rgba(135,206,235,0.25)}
.add-event-btn{position:fixed;bottom:30px;right:30px;width:60px;height:60px;border-radius:50%;background:var(--accent);border:none;color:white;font-size:1.5rem;box-shadow:0 4px 15px rgba(0,0,0,0.3);transition:var(--transition);z-index:1000}
.add-event-btn:hover{transform:scale(1.1);background:var(--primary)}
.trip-setup{text-align:center;padding:40px 20px}
.trip-setup h2{color:var(--accent);margin-bottom:30px}
.date-input-group{display:flex;align-items:center;justify-content:center;gap:15px;margin:20px 0;flex-wrap:wrap}
.date-input-group input[type="date"]{padding:10px;border:2px solid var(--secondary);border-radius:8px;font-size:1rem}
.date-input-group span{font:bold 1.2rem/1 sans-serif;color:var(--accent)}

/* 天気アイコン用スタイル（左上配置・大きめサイズ） */
.weather-emoji-top-left {
    position: absolute;
    top: -4px;
    left: -4px;
    font-size: 2.4rem;
    z-index: 30;
    line-height: 1;
    pointer-events: none;
}

/* OpenStreetMap地図のスタイル */
.map-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.map-container {
    width: 90%;
    max-width: 800px;
    height: 80%;
    max-height: 600px;
    background: white;
    border-radius: 10px;
    position: relative;
    overflow: hidden;
}

.map-header {
    background: var(--primary);
    color: white;
    padding: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.map-close-btn {
    background: none;
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.3s;
}

.map-close-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

#map {
    width: 100%;
    height: calc(100% - 60px);
}

.map-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    font-size: 0.9rem;
    text-align: center;
}

@media (max-width:768px){
.header{padding:6px 0}
.timeline-header{padding:6px 15px}
.timeline-header h5{font-size:0.9rem}
.timeline-header h5 small{font-size:0.75rem;display:block;margin-left:0;margin-top:2px}
.day-tabs{margin:8px 0 0 0}
.time-axis{width:60px;height:1000px}
.time-slot{height:50px;font-size:0.8rem}
.grid-line{height:50px}
.schedule-grid,.schedule-area{height:1000px}
.event-block{padding:6px 8px 6px 22px;min-height:32px}
.event-content-inline{font-size:0.8rem}
.date-input-group{flex-direction:column;gap:10px}
.event-action-btn{width:35px;height:35px;font-size:0.9rem}
.event-block.overlapping{opacity:0.7;border:2px solid #ff6b6b}
.weather-emoji-top-left{font-size:1.5rem}
}
</style>
</head>
<body>
<div id="app">
<header class="header">
<div class="container">
<h1><i class="fas fa-snowflake penguin-icon"></i>とりっぺんちゃん</h1>
<p class="mb-0">みんなで楽しい旅行計画を立てよう！</p>
</div>
</header>
<div v-if="!tripInitialized" class="container">
<div class="trip-setup">
<h2><i class="fas fa-calendar-alt"></i> 旅行日程を設定してください</h2>
<p>旅行の開始日と終了日を選択して、スケジュールを作成しましょう！</p>
<div class="date-input-group">
<label for="startDate"><strong>開始日:</strong></label>
<input type="date" id="startDate" v-model="tripStartDate" :min="today">
<span>〜</span>
<label for="endDate"><strong>終了日:</strong></label>
<input type="date" id="endDate" v-model="tripEndDate" :min="tripStartDate">
</div>
<div class="mt-4">
<button class="btn btn-primary btn-lg" @click="initializeTripDays" :disabled="!tripStartDate || !tripEndDate">
<i class="fas fa-check"></i> 旅行スケジュールを作成
</button>
</div>
<div class="mt-3">
<button class="btn btn-outline-secondary" @click="loadExistingData" v-if="hasExistingData">
<i class="fas fa-folder-open"></i> 既存のデータを読み込む
</button>
</div>
</div>
</div>
<div v-if="tripInitialized && !isMobile" class="desktop-ui">
<div class="day-tabs-container">
<ul class="nav nav-tabs day-tabs">
<li class="nav-item" v-for="(day, index) in tripDays" :key="`day-${day.id || index}`">
<a class="nav-link" :class="{ active: activeDay === index }" @click="setActiveDay(index)" href="#" @click.prevent>
<div>
<div>{{ day.dayNumber }}日目</div>
<small :class="{ 'editable-date': index === 0 }">
{{ day.date }}
<i v-if="index === 0" class="fas fa-edit" @click.stop="handleDateClick(index)" style="cursor: pointer; margin-left: 4px; padding: 2px; border-radius: 3px; transition: background 0.2s;" @mouseover="$event.target.style.background='rgba(255,255,255,0.2)'" @mouseout="$event.target.style.background='transparent'" title="開始日を変更"></i>
</small>
</div>
<button class="delete-day-btn" v-if="tripDays.length > 1" @click.stop.prevent="deleteDay(index)" @mousedown.stop title="日程を削除">
<i class="fas fa-times"></i>
</button>
</a>
</li>
<li class="nav-item">
<a class="nav-link add-day-btn" @click.prevent.stop="addDayImmediately" @mousedown.stop href="#" title="日程を追加">
<div>
<div style="font-size: 1.5rem; font-weight: bold;">＋</div>
<small style="visibility: hidden;">日程追加</small>
</div>
</a>
</li>
</ul>
</div>
<div class="timeline-container">
<div class="timeline-header">
<h5>
<i class="fas fa-calendar-day"></i>
{{ tripDays[activeDay]?.dayNumber }}日目の予定
<small class="text-muted">{{ tripDays[activeDay]?.date }}</small>
</h5>
</div>
<div class="timeline-content">
<div class="timeline-scroll-container" ref="scrollContainer">
<div class="time-axis">
<div class="time-slot" v-for="hour in timeSlots" :key="hour">
{{ hour }}:00
</div>
</div>
<div class="schedule-area" @click="editModeEvent = null" @contextmenu="handleScheduleContextMenu">
<div class="schedule-grid">
<div class="grid-line" v-for="hour in timeSlots" :key="hour">
<div class="quarter-line"></div>
<div class="quarter-line"></div>
<div class="quarter-line"></div>
</div>
</div>
<div class="event-block" v-for="event in getCurrentDayEvents()" :key="event.id" :class="[
'event-category-' + event.category,
{ 'edit-mode': editModeEvent && editModeEvent.id === event.id },
{ 'dragging': draggingEvent && draggingEvent.id === event.id },
{ 'ready-to-move': readyToMoveEventId === event.id }
]" :style="getEventStyle(event)" @contextmenu.prevent="handleEventContextMenu($event, event)" @click="handleEventClick($event, event)" @mousedown="handleEventMouseDown($event, event)">
<div class="event-content-inline">
<i :class="getCategoryIcon(event.category)"></i>
{{ event.inlineText }}
</div>
<span class="weather-emoji-top-left" v-if="getEventWeatherEmoji(event)">
{{ getEventWeatherEmoji(event) }}
</span>
<div class="event-actions" v-if="editModeEvent && editModeEvent.id === event.id">
<button class="event-action-btn cut" @click="handleCutButtonClick($event, event)" @mousedown.stop title="切り取り">
<i class="fas fa-cut"></i>
</button>
</div>
<div class="resize-handle top" v-if="editModeEvent && editModeEvent.id === event.id" @mousedown="startResize($event, event, 'top')"></div>
<div class="resize-handle bottom" v-if="editModeEvent && editModeEvent.id === event.id" @mousedown="startResize($event, event, 'bottom')"></div>
</div>
</div>
</div>
</div>
</div>
<button class="add-event-btn" @click="openEventModal()">
<i class="fas fa-plus"></i>
</button>
</div>
<div v-if="tripInitialized && isMobile" class="mobile-ui">
<div class="mobile-day-selector">
<div class="mobile-scroll-container">
<button class="mobile-scroll-nav left" :class="{ disabled: scrollPosition <= 0 }" @click="scrollToDirection('left')">
<i class="fas fa-chevron-left"></i>
</button>
<div class="mobile-day-buttons" ref="mobileScrollContainer" @scroll="updateScrollPosition">
<button v-for="(day, index) in tripDays" :key="`mobile-day-${day.id || index}`" class="mobile-day-btn" :class="{ active: activeDay === index }" @click="setActiveDay(index)" @touchstart="handleMobileDayTouchStart($event, index)" @touchend="handleMobileDayTouchEnd($event, index)">
<div>{{ day.dayNumber }}日目</div>
<small>{{ day.date }}</small>
</button>
</div>
<button class="mobile-scroll-nav right" :class="{ disabled: scrollPosition >= maxScrollPosition }" @click="scrollToDirection('right')">
<i class="fas fa-chevron-right"></i>
</button>
</div>
</div>
<div class="timeline-container">
<div class="timeline-header">
<h5>
<i class="fas fa-calendar-day"></i>
{{ tripDays[activeDay]?.dayNumber }}日目の予定
<small class="text-muted">{{ tripDays[activeDay]?.date }}</small>
</h5>
</div>
<div class="timeline-content">
<div class="timeline-scroll-container" ref="mobileTimelineContainer">
<div class="time-axis">
<div class="time-slot" v-for="hour in timeSlots" :key="hour">
{{ hour }}:00
</div>
</div>
<div class="schedule-area" @click="editModeEvent = null" @touchstart="handleScheduleTouchStart" @touchend="handleScheduleTouchEnd" @touchmove="handleScheduleTouchMove">
<div class="schedule-grid">
<div class="grid-line" v-for="hour in timeSlots" :key="hour">
<div class="quarter-line"></div>
<div class="quarter-line"></div>
<div class="quarter-line"></div>
</div>
</div>
<div class="event-block" v-for="event in getCurrentDayEvents()" :key="event.id" :class="[
'event-category-' + event.category,
{ 'edit-mode': editModeEvent && editModeEvent.id === event.id },
{ 'dragging': draggingEvent && draggingEvent.id === event.id },
{ 'ready-to-move': readyToMoveEventId === event.id }
]" :style="getEventStyle(event)" @click="handleEventClick($event, event)" @touchstart="handleEventTouchStart($event, event)">
<div class="event-content-inline">
<i :class="getCategoryIcon(event.category)"></i>
{{ event.inlineText }}
</div>
<span class="weather-emoji-top-left" v-if="getEventWeatherEmoji(event)">
{{ getEventWeatherEmoji(event) }}
</span>
<div class="event-actions" v-if="editModeEvent && editModeEvent.id === event.id">
<button class="event-action-btn cut" @click="handleCutButtonClick($event, event)" @touchstart.stop title="切り取り">
<i class="fas fa-cut"></i>
</button>
</div>
<div class="resize-handle top" v-if="editModeEvent && editModeEvent.id === event.id" @touchstart="startResizeTouch($event, event, 'top')"></div>
<div class="resize-handle bottom" v-if="editModeEvent && editModeEvent.id === event.id" @touchstart="startResizeTouch($event, event, 'bottom')"></div>
</div>
</div>
</div>
</div>
</div>
<button class="mobile-fab" @click="openEventModal()">
<i class="fas fa-plus"></i>
</button>
</div>
<div class="context-menu" :class="{ show: showContextMenu }" :style="contextMenuStyle">
<div class="context-menu-item add-event" @click="addEventFromContext">
<i class="fas fa-plus"></i>新しい予定を追加
</div>
<div class="context-menu-item paste" :class="{ disabled: !clipboardEvent }" @click="pasteFromContext" v-if="clipboardEvent">
<i class="fas fa-paste"></i>貼り付け
</div>
<div class="context-menu-item disabled" v-else>
<i class="fas fa-paste"></i>貼り付け（コピー済みアイテムなし）
</div>
</div>
<div class="mobile-popup-menu" :class="{ show: showMobilePopup }" @click="closeMobilePopup" v-if="isMobile">
<div class="mobile-popup-content" @click.stop>
<div class="mobile-popup-title">{{ selectedDayForPopup ? `${selectedDayForPopup.dayNumber}日目の編集` : '日程編集' }}</div>
<div class="mobile-popup-buttons">
<button class="mobile-popup-btn primary" v-if="selectedDayForPopup && selectedDayIndex === 0" @click="openStartDateModalFromPopup">
<i class="fas fa-calendar-edit"></i>開始日を変更
</button>
<button class="mobile-popup-btn success" @click="addDayFromPopup">
<i class="fas fa-plus"></i>日程を追加
</button>
<button class="mobile-popup-btn danger" v-if="selectedDayForPopup && tripDays.length > 1" @click="deleteDayFromPopup">
<i class="fas fa-trash"></i>この日程を削除
</button>
<button class="mobile-popup-btn secondary" @click="closeMobilePopup">
<i class="fas fa-times"></i>キャンセル
</button>
</div>
</div>
</div>

<!-- OpenStreetMap地図モーダル（指示通りのみ）-->
<div v-if="showMapModal" class="map-modal" @click="closeMapModal">
    <div class="map-container" @click.stop>
        <div class="map-header">
            <h5><i class="fas fa-map-marker-alt"></i> 位置を選択</h5>
            <button class="map-close-btn" @click="closeMapModal">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div id="map"></div>
        <div class="map-info">
            <i class="fas fa-info-circle"></i> 地図上をタップして位置を選択してください
            <div v-if="selectedCoordinates" class="mt-2">
                <strong>選択した座標:</strong> {{ selectedCoordinates }}
            </div>
        </div>
    </div>
</div>

<div v-for="modal in modals" :key="modal.id" class="modal fade" :id="modal.id" tabindex="-1">
<div class="modal-dialog" :class="modal.size">
<div class="modal-content">
<div class="modal-header">
<h5 class="modal-title">{{ modal.title }}</h5>
<button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
</div>
<div class="modal-body" v-html="modal.body"></div>
<div class="modal-footer" v-html="modal.footer"></div>
</div>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const { createApp } = Vue;
const app = createApp({
data() {
return {
tripInitialized: false,
tripStartDate: '',
tripEndDate: '',
today: new Date().toISOString().split('T')[0],
hasExistingData: false,
tripDays: [],
activeDay: 0,
showMobilePopup: false,
selectedDayForPopup: null,
selectedDayIndex: null,
scrollPosition: 0,
maxScrollPosition: 0,
timeSlots: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],
events: [],
editModeEvent: null,
clipboardEvent: null,
showContextMenu: false,
contextMenuStyle: {},
pasteTargetTime: null,
isMobile: false,
touchStartTime: 0,
touchStartPosition: { x: 0, y: 0 },
longPressTimer: null,
longPressExecuted: false,
eventTouchOffset: { x: 0, y: 0 },
draggingEvent: null,
isDragComplete: false,
isResizeComplete: false,
dragStarted: false,
longPressEventData: null,
longPressEvent: null,
readyToMoveEventId: null,
// OpenStreetMap地図機能用のデータ
showMapModal: false,
map: null,
selectedCoordinates: null,
mapMarker: null,
eventForm: {
title: '',
dayIndex: 0,
startTime: '09:00',
endTime: '10:00',
category: 'travel',
description: '',
coordinates: ''
},
modals: [],
// ドラッグした順序でz-indexを管理
eventLayerOrder: [],
baseZIndex: 10,
maxZIndex: 10,
// 天気予報機能のデータ
weatherCache: {},
weatherCacheExpiry: 6 * 60 * 60 * 1000 // 6時間（ミリ秒）
};
},
methods: {
linkifyUrls(text) {
if (!text) return text;
const urlRegex = /(https?:\/\/[^\s]+)/g;
return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
},
checkExistingData() {
this.hasExistingData = !!(localStorage.getItem('trippenEvents') && localStorage.getItem('trippenDays'));
},
loadExistingData() {
this.loadData();
if (this.tripDays.length > 0) this.tripInitialized = true;
},
initializeTripDays() {
if (!this.tripStartDate || !this.tripEndDate || this.tripStartDate > this.tripEndDate) {
alert('正しい日付を選択してください');
return;
}
this.tripDays = this.generateTripDays(this.tripStartDate, this.tripEndDate);
this.activeDay = 0;
this.tripInitialized = true;
this.saveData();
},
generateTripDays(startDate, endDate) {
const days = [];
const start = new Date(startDate);
const end = new Date(endDate);
const dayNames = ['日', '月', '火', '水', '木', '金', '土'];
let dayNumber = 1;
for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
days.push({
id: Date.now() + dayNumber + Math.random(),
dayNumber: dayNumber++,
date: `${date.getMonth() + 1}/${date.getDate()}(${dayNames[date.getDay()]})`,
fullDate: date.toISOString().split('T')[0]
});
}
return days;
},
setActiveDay(index) { this.activeDay = index; },
detectMobile() { this.isMobile = window.innerWidth <= 768 || 'ontouchstart' in window; },
addDayImmediately() {
const startDate = this.tripDays[0].fullDate;
this.tripDays = this.generateConsecutiveDays(startDate, this.tripDays.length + 1);
this.saveData();
},
deleteDay(index) {
if (this.tripDays.length <= 1) {
alert('最低1つの日程は必要です');
return;
}
if (confirm(`${this.tripDays[index].dayNumber}日目を削除しますか？`)) {
this.events = this.events.filter(event => event.dayIndex !== index)
.map(event => event.dayIndex > index ? { ...event, dayIndex: event.dayIndex - 1 } : event);
this.tripDays = this.generateConsecutiveDays(this.tripDays[0].fullDate, this.tripDays.length - 1);
if (this.activeDay >= this.tripDays.length) this.activeDay = this.tripDays.length - 1;
this.saveData();
}
},
generateConsecutiveDays(startDate, dayCount) {
const days = [];
const start = new Date(startDate);
const dayNames = ['日', '月', '火', '水', '木', '金', '土'];
for (let i = 0; i < dayCount; i++) {
const date = new Date(start);
date.setDate(start.getDate() + i);
days.push({
id: Date.now() + i + Math.random(),
dayNumber: i + 1,
date: `${date.getMonth() + 1}/${date.getDate()}(${dayNames[date.getDay()]})`,
fullDate: date.toISOString().split('T')[0]
});
}
return days;
},
handleDateClick(index) {
if (index === 0) this.openStartDateModal();
else this.setActiveDay(index);
},
getCurrentDayEvents() {
return this.events
.filter(event => event.dayIndex === this.activeDay)
.map(event => {
const inlineText = `${event.title}（${event.startTime}-${event.endTime}）`;
return {
...event,
inlineText
};
});
},
// 重なり判定メソッド
checkEventOverlap(eventA, eventB) {
if (eventA.dayIndex !== eventB.dayIndex) return false;
  
const startA = this.timeToMinutes(eventA.startTime);
const endA = this.timeToMinutes(eventA.endTime);
const startB = this.timeToMinutes(eventB.startTime);
const endB = this.timeToMinutes(eventB.endTime);
  
return !(endA <= startB || endB <= startA);
},

// 特定のイベントと重なる全てのイベントを取得
getOverlappingEvents(targetEvent) {
return this.events.filter(event => 
event.id !== targetEvent.id && 
this.checkEventOverlap(targetEvent, event)
);
},

// z-indexを更新する
updateEventZIndex(eventId) {
const targetEvent = this.events.find(e => e.id === eventId);
if (!targetEvent) return;
  
const overlappingEvents = this.getOverlappingEvents(targetEvent);
  
// 重なりがない場合は何もしない
if (overlappingEvents.length === 0) return;
  
// 既存の順序から削除
this.eventLayerOrder = this.eventLayerOrder.filter(id => id !== eventId);
  
// 最前面に追加
this.eventLayerOrder.push(eventId);
  
// 最大z-indexを更新
this.maxZIndex = Math.max(this.maxZIndex, this.baseZIndex + this.eventLayerOrder.length);
  
// データを保存
this.saveLayerOrder();
},

handleEventClick(event, eventData) {
if (this.isDragComplete) {
this.isDragComplete = false;
return;
}
if (this.isResizeComplete) {
this.isResizeComplete = false;
return;
}
if (this.draggingEvent) {
return;
}
if (this.editModeEvent && this.editModeEvent.id === eventData.id) {
return;
}
if (!event.target.closest('.event-action-btn') && 
!event.target.closest('.resize-handle')) {
this.openDetailModal(eventData);
}
},
handleEventMouseDown(event, eventData) {
if (this.editModeEvent && this.editModeEvent.id === eventData.id) {
if (!event.target.closest('.event-action-btn') && 
!event.target.closest('.resize-handle')) {
event.preventDefault();
event.stopPropagation();
this.startEventDrag(event, eventData);
}
}
},
handleEventContextMenu(event, eventData) {
event.preventDefault();
event.stopPropagation();
this.editModeEvent = this.editModeEvent?.id === eventData.id ? null : eventData;
if (navigator.vibrate) navigator.vibrate(50);
},
startEventDrag(event, eventData) {
this.draggingEvent = eventData;
this.isDragComplete = false;
const startY = event.clientY;
const container = this.$refs.scrollContainer || this.$refs.mobileTimelineContainer;
const rect = container.getBoundingClientRect();
const timelineHeader = container.querySelector('.timeline-header');
const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
const centerOffset = (this.timeToPixels(eventData.endTime) - this.timeToPixels(eventData.startTime)) / 2;
const moveHandler = (e) => {
const newCenterTop = e.clientY - rect.top - headerHeight + container.scrollTop;
const newStartTop = newCenterTop - centerOffset;
const snappedTop = Math.round(newStartTop / 15) * 15;
this.updateEventTimeFromDrag(eventData, snappedTop);
};
const endHandler = () => {
document.removeEventListener('mousemove', moveHandler);
document.removeEventListener('mouseup', endHandler);
this.draggingEvent = null;
this.isDragComplete = true;

// ドラッグした予定のz-indexを更新
this.updateEventZIndex(eventData.id);

this.saveData();
setTimeout(() => {
this.isDragComplete = false;
}, 150);
};
document.addEventListener('mousemove', moveHandler);
document.addEventListener('mouseup', endHandler);
},
startEventDragTouch(event, eventData) {
this.draggingEvent = eventData;
this.isDragComplete = false;
const coords = event.touches[0];
const container = this.$refs.mobileTimelineContainer;
const rect = container.getBoundingClientRect();
const timelineHeader = container.querySelector('.timeline-header');
const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
const centerOffset = (this.timeToPixels(eventData.endTime) - this.timeToPixels(eventData.startTime)) / 2;
const moveHandler = (e) => {
e.preventDefault();
const touch = e.touches[0];
const newCenterTop = touch.clientY - rect.top - headerHeight + container.scrollTop;
const newStartTop = newCenterTop - centerOffset;
const snappedTop = Math.round(newStartTop / 15) * 15;
this.updateEventTimeFromDrag(eventData, snappedTop);
};
const endHandler = () => {
document.removeEventListener('touchmove', moveHandler);
document.removeEventListener('touchend', endHandler);
this.draggingEvent = null;
this.isDragComplete = true;

// ドラッグした予定のz-indexを更新
this.updateEventZIndex(eventData.id);

this.saveData();
setTimeout(() => {
this.isDragComplete = false;
}, 150);
};
document.addEventListener('touchmove', moveHandler, { passive: false });
document.addEventListener('touchend', endHandler, { passive: true });
},
updateEventTimeFromDrag(eventData, snappedTop) {
const minTime = '04:00';
const maxTime = '24:00';
const eventIndex = this.events.findIndex(ev => ev.id === eventData.id);
if (eventIndex === -1) return;
  
const currentDuration = this.timeToMinutes(this.events[eventIndex].endTime) - this.timeToMinutes(this.events[eventIndex].startTime);
const newTime = this.pixelsToTime(snappedTop);
const newEndTime = this.minutesToTime(this.timeToMinutes(newTime) + currentDuration);
  
if (newTime < minTime) {
this.events[eventIndex].startTime = minTime;
this.events[eventIndex].endTime = this.minutesToTime(this.timeToMinutes(minTime) + currentDuration);
return;
}
  
if (newEndTime > maxTime) {
this.events[eventIndex].endTime = maxTime;
this.events[eventIndex].startTime = this.minutesToTime(this.timeToMinutes(maxTime) - currentDuration);
return;
}
  
this.events[eventIndex].startTime = newTime;
this.events[eventIndex].endTime = newEndTime;
},
handleMobileDayTouchStart(event, index) {
this.touchStartTime = Date.now();
this.longPressTimer = setTimeout(() => {
if (navigator.vibrate) navigator.vibrate(50);
this.showMobilePopupForDay(index);
}, 800);
},
handleMobileDayTouchEnd(event, index) {
if (this.longPressTimer) {
clearTimeout(this.longPressTimer);
this.longPressTimer = null;
}
if (Date.now() - this.touchStartTime < 500) this.setActiveDay(index);
},
showMobilePopupForDay(index) {
this.selectedDayForPopup = this.tripDays[index];
this.selectedDayIndex = index;
this.showMobilePopup = true;
},
closeMobilePopup() {
this.showMobilePopup = false;
this.selectedDayForPopup = null;
this.selectedDayIndex = null;
},
openStartDateModalFromPopup() {
this.closeMobilePopup();
setTimeout(() => this.openStartDateModal(), 300);
},
addDayFromPopup() {
this.closeMobilePopup();
setTimeout(() => this.addDayImmediately(), 300);
},
deleteDayFromPopup() {
const index = this.selectedDayIndex;
this.closeMobilePopup();
setTimeout(() => index !== null && this.deleteDay(index), 300);
},
updateScrollPosition() {
const container = this.$refs.mobileScrollContainer;
if (!container) return;
this.scrollPosition = container.scrollLeft;
this.maxScrollPosition = container.scrollWidth - container.clientWidth;
},
scrollToDirection(direction) {
const container = this.$refs.mobileScrollContainer;
if (!container) return;
container.scrollBy({ left: direction === 'left' ? -120 : 120, behavior: 'smooth' });
},
handleEventTouchStart(event, eventData) {
if (this.isDragComplete) {
return;
}
if (this.draggingEvent) {
return;
}
if (this.editModeEvent && this.editModeEvent.id === eventData.id) {
if (!event.target.closest('.event-action-btn') && 
!event.target.closest('.resize-handle')) {
event.preventDefault();
event.stopPropagation();
this.startEventDragTouch(event, eventData);
}
} else {
if (!event.target.closest('.event-action-btn') && 
!event.target.closest('.resize-handle')) {
event.preventDefault();
event.stopPropagation();
this.touchStartTime = Date.now();
this.longPressExecuted = false;
this.dragStarted = false;
this.longPressEventData = eventData;
this.longPressEvent = event;
this.readyToMoveEventId = null;
this.touchStartPosition = { 
x: event.touches[0].clientX, 
y: event.touches[0].clientY 
};
this.longPressTimer = setTimeout(() => {
this.longPressExecuted = true;
this.readyToMoveEventId = eventData.id;
if (navigator.vibrate) navigator.vibrate(50);
}, 500);
const handleTouchMove = (e) => {
if (!this.longPressExecuted) return;
const deltaX = Math.abs(e.touches[0].clientX - this.touchStartPosition.x);
const deltaY = Math.abs(e.touches[0].clientY - this.touchStartPosition.y);
if ((deltaX > 5 || deltaY > 5) && !this.dragStarted) {
this.dragStarted = true;
this.editModeEvent = eventData;
this.readyToMoveEventId = null;
this.startEventDragTouch(this.longPressEvent, eventData);
}
};
const handleTouchEnd = () => {
if (this.longPressTimer) {
clearTimeout(this.longPressTimer);
this.longPressTimer = null;
}
const touchDuration = Date.now() - this.touchStartTime;
if (this.longPressExecuted && !this.dragStarted) {
this.editModeEvent = eventData;
this.readyToMoveEventId = null;
} else if (!this.longPressExecuted && touchDuration < 500) {
this.openDetailModal(eventData);
}
this.dragStarted = false;
this.longPressEventData = null;
this.longPressEvent = null;
this.readyToMoveEventId = null;
document.removeEventListener('touchmove', handleTouchMove);
document.removeEventListener('touchend', handleTouchEnd);
};
document.addEventListener('touchmove', handleTouchMove, { passive: false });
document.addEventListener('touchend', handleTouchEnd, { passive: true });
}
}
},
handleCutButtonClick(event, eventData) {
event.preventDefault();
event.stopPropagation();
this.cutEvent(eventData);
},
cutEvent(event) {
try {
this.clipboardEvent = { ...event };
const eventIndex = this.events.findIndex(e => e.id === event.id);
if (eventIndex !== -1) {
this.events.splice(eventIndex, 1);
this.editModeEvent = null;
this.saveData();
if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
}
} catch (error) {
console.error('予定の切り取り中にエラーが発生しました:', error);
alert('予定の切り取りに失敗しました。');
}
},
pasteFromContext() {
if (!this.clipboardEvent) return;
const newEvent = {
...this.clipboardEvent,
id: Date.now() + Math.random(),
dayIndex: this.activeDay
};
if (this.pasteTargetTime) {
const duration = this.timeToMinutes(this.clipboardEvent.endTime) - this.timeToMinutes(this.clipboardEvent.startTime);
const startMinutes = this.timeToMinutes(this.pasteTargetTime);
let endMinutes = startMinutes + duration;
if (endMinutes > 1440) {
endMinutes = 1440;
}
newEvent.startTime = this.pasteTargetTime;
newEvent.endTime = this.minutesToTime(endMinutes);
}
this.events.push(newEvent);
this.clipboardEvent = null;
this.hideContextMenu();
this.saveData();
},
addEventFromContext() {
if (!this.pasteTargetTime) return;
const startMinutes = this.timeToMinutes(this.pasteTargetTime);
const endTime = this.minutesToTime(startMinutes + 60);
this.eventForm = {
title: '',
dayIndex: this.activeDay,
startTime: this.pasteTargetTime,
endTime: endTime,
category: 'travel',
description: '',
coordinates: ''
};
this.hideContextMenu();
setTimeout(() => {
this.openEventModal(null, true);
}, 100);
},
timeToMinutes(timeString) {
const [hours, minutes] = timeString.split(':').map(Number);
return hours * 60 + minutes;
},
minutesToTime(minutes) {
const hours = Math.floor(minutes / 60);
const mins = minutes % 60;
return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
},
timeToPixels(timeString) {
const [hours, minutes] = timeString.split(':').map(Number);
const totalMinutes = (hours - 4) * 60 + minutes;
return totalMinutes * (this.isMobile ? 50/60 : 1);
},
pixelsToTime(pixels) {
const totalMinutes = pixels / (this.isMobile ? 50/60 : 1);
const roundedMinutes = Math.round(totalMinutes / 15) * 15;
const hours = Math.max(4, Math.min(24, Math.floor(roundedMinutes / 60) + 4));
const minutes = hours === 24 ? 0 : roundedMinutes % 60;
return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
},
handleScheduleContextMenu(event) {
if (!this.isMobile) {
event.preventDefault();
this.showContextMenuAt(event.clientX, event.clientY, event);
}
},
showContextMenuAt(x, y, event) {
const container = this.isMobile ? this.$refs.mobileTimelineContainer : this.$refs.scrollContainer;
const timelineHeader = container.querySelector('.timeline-header');
const scheduleArea = container.querySelector('.schedule-area');
if (!scheduleArea) {
const containerRect = container.getBoundingClientRect();
this.pasteTargetTime = this.pixelsToTime(y - containerRect.top + container.scrollTop);
} else {
const containerRect = container.getBoundingClientRect();
const scheduleAreaRect = scheduleArea.getBoundingClientRect();
const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
const relativeY = y - containerRect.top - headerHeight + container.scrollTop;
const snappedY = Math.round(relativeY / 15) * 15;
this.pasteTargetTime = this.pixelsToTime(Math.max(0, snappedY));
}
this.contextMenuStyle = { left: `${x}px`, top: `${y}px` };
this.showContextMenu = true;
setTimeout(() => {
document.addEventListener('click', this.hideContextMenu, { once: true });
}, 100);
},
hideContextMenu() { this.showContextMenu = false; },
handleScheduleTouchStart(event) {
if (!this.isMobile) return;
if (event.target.closest('.event-block')) {
return;
}
this.touchStartTime = Date.now();
this.touchStartPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
this.longPressTimer = setTimeout(() => {
this.showContextMenuAt(this.touchStartPosition.x, this.touchStartPosition.y, event);
if (navigator.vibrate) navigator.vibrate(50);
}, 500);
},
handleScheduleTouchMove(event) {
if (!this.isMobile) return;
if (event.target.closest('.event-block')) {
return;
}
const deltaX = Math.abs(event.touches[0].clientX - this.touchStartPosition.x);
const deltaY = Math.abs(event.touches[0].clientY - this.touchStartPosition.y);
if (deltaX > 10 || deltaY > 10) this.clearLongPress();
},
handleScheduleTouchEnd(event) {
if (!this.isMobile) return;
if (event.target.closest('.event-block')) {
return;
}
this.clearLongPress();
if (Date.now() - this.touchStartTime < 300) this.editModeEvent = null;
},
clearLongPress() {
if (this.longPressTimer) {
clearTimeout(this.longPressTimer);
this.longPressTimer = null;
}
},
startResize(event, eventData, direction) {
this.startResizeHandler(event, direction, 'mouse');
},
startResizeTouch(event, eventData, direction) {
this.startResizeHandler(event, direction, 'touch');
},
startResizeHandler(event, direction, type) {
event.preventDefault();
event.stopPropagation();
const moveEvent = type === 'touch' ? 'touchmove' : 'mousemove';
const endEvent = type === 'touch' ? 'touchend' : 'mouseup';
const moveHandler = (e) => {
const coords = type === 'touch' ? e.touches[0] : e;
const container = this.isMobile ? this.$refs.mobileTimelineContainer : this.$refs.scrollContainer;
const rect = container.getBoundingClientRect();
const timelineHeader = container.querySelector('.timeline-header');
const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
const y = coords.clientY - rect.top - headerHeight + container.scrollTop;
const snappedY = Math.round(y / 15) * 15;
const newTime = this.pixelsToTime(snappedY);
const eventIndex = this.events.findIndex(ev => ev.id === this.editModeEvent.id);
if (eventIndex === -1) return;
if (direction === 'top' && newTime < this.events[eventIndex].endTime) {
this.events[eventIndex].startTime = newTime;
} else if (direction === 'bottom' && newTime > this.events[eventIndex].startTime) {
this.events[eventIndex].endTime = newTime;
}
};
const endHandler = () => {
document.removeEventListener(moveEvent, moveHandler);
document.removeEventListener(endEvent, endHandler);
this.isResizeComplete = true;
this.saveData();
setTimeout(() => {
this.isResizeComplete = false;
}, 150);
};
document.addEventListener(moveEvent, moveHandler, { passive: false });
document.addEventListener(endEvent, endHandler);
},
getEventStyle(event) {
const startPixels = this.timeToPixels(event.startTime);
const endPixels = this.timeToPixels(event.endTime);
const duration = Math.max(endPixels - startPixels, this.isMobile ? 25 : 30);

// z-indexを動的に設定
let zIndex = this.baseZIndex;
const layerIndex = this.eventLayerOrder.indexOf(event.id);
if (layerIndex !== -1) {
zIndex = this.baseZIndex + layerIndex + 1;
}

return {
top: `${startPixels}px`,
height: `${duration}px`,
minHeight: this.isMobile ? '32px' : '35px',
zIndex: zIndex
};
},
getCategoryIcon(category) {
const icons = {
travel: 'fas fa-car',
food: 'fas fa-utensils',
sightseeing: 'fas fa-camera',
accommodation: 'fas fa-bed',
custom: 'fas fa-star'
};
return icons[category] || 'fas fa-calendar';
},

// 天気予報を取得する
async fetchWeatherForEvent(event) {
if (!event.coordinates) return null;

try {
const [lat, lng] = event.coordinates.split(',').map(Number);
if (isNaN(lat) || isNaN(lng)) return null;

const cacheKey = `${lat},${lng}_${event.dayIndex}`;
const cachedWeather = this.weatherCache[cacheKey];

// キャッシュが有効な場合は返す
if (cachedWeather && Date.now() - cachedWeather.timestamp < this.weatherCacheExpiry) {
return cachedWeather.data;
}

const dayData = this.tripDays[event.dayIndex];
if (!dayData) return null;

const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=weathercode&timezone=auto&start_date=${dayData.fullDate}&end_date=${dayData.fullDate}`;

const response = await fetch(url);
if (!response.ok) throw new Error('Weather API request failed');

const data = await response.json();
const weatherCode = data.daily.weathercode[0];

// キャッシュに保存
this.weatherCache[cacheKey] = {
data: weatherCode,
timestamp: Date.now()
};

return weatherCode;
} catch (error) {
console.error('天気予報の取得に失敗しました:', error);
return null;
}
},

// 天気コードを絵文字に変換
getWeatherEmoji(weatherCode) {
if (!weatherCode) return '';

const weatherMap = {
0: '☀️',    // 晴れ
1: '🌤️',   // 主に晴れ
2: '⛅',    // 部分的に曇り
3: '☁️',    // 曇り
45: '🌫️',  // 霧
48: '🌫️',  // 霧氷
51: '🌦️',  // 軽い霧雨
53: '🌦️',  // 中程度の霧雨
55: '🌧️',  // 激しい霧雨
56: '🌧️',  // 軽い氷雨
57: '🌧️',  // 激しい氷雨
61: '🌧️',  // 軽い雨
63: '🌧️',  // 中程度の雨
65: '🌧️',  // 激しい雨
66: '🌧️',  // 軽い氷雨
67: '🌧️',  // 激しい氷雨
71: '🌨️',  // 軽い雪
73: '🌨️',  // 中程度の雪
75: '🌨️',  // 激しい雪
77: '🌨️',  // 雪の粒
80: '🌦️',  // 軽いにわか雨
81: '🌦️',  // 中程度のにわか雨
82: '🌧️',  // 激しいにわか雨
85: '🌨️',  // 軽いにわか雪
86: '🌨️',  // 激しいにわか雪
95: '⛈️',  // 雷雨
96: '⛈️',  // 軽い雹を伴う雷雨
99: '⛈️'   // 激しい雹を伴う雷雨
};

return weatherMap[weatherCode] || '';
},

// 全ての予定の天気予報を取得
async loadWeatherForAllEvents() {
const promises = this.events
.filter(event => event.coordinates)
.map(event => this.fetchWeatherForEvent(event));

await Promise.all(promises);
},

// 予定の天気予報絵文字を取得
getEventWeatherEmoji(event) {
if (!event.coordinates) return '';

const cacheKey = `${event.coordinates}_${event.dayIndex}`;
const cachedWeather = this.weatherCache[cacheKey];

if (cachedWeather && Date.now() - cachedWeather.timestamp < this.weatherCacheExpiry) {
return this.getWeatherEmoji(cachedWeather.data);
}

return '';
},

// OpenStreetMap地図機能メソッド（指示通りのみ）
setLocationFromMap() {
this.showMapModal = true;
this.$nextTick(() => {
this.initializeMap();
});
},

initializeMap() {
// 大阪府大阪市北区の座標 (34.7024, 135.4959)
const initialLat = 34.7024;
const initialLng = 135.4959;

this.map = L.map('map').setView([initialLat, initialLng], 15);

// OpenStreetMap APIを使用
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
attribution: '© OpenStreetMap contributors'
}).addTo(this.map);

// 地図クリック（タップ）イベント - 座標取得
this.map.on('click', (e) => {
this.handleMapClick(e);
});
},

handleMapClick(e) {
const lat = e.latlng.lat.toFixed(6);
const lng = e.latlng.lng.toFixed(6);
this.selectedCoordinates = `${lat},${lng}`;

// 既存のマーカーを削除
if (this.mapMarker) {
this.map.removeLayer(this.mapMarker);
}

// 新しいマーカーを追加
this.mapMarker = L.marker([lat, lng]).addTo(this.map);

// 座標を入力フィールドに設定
const coordinatesInput = document.getElementById('eventCoordinates');
if (coordinatesInput) {
coordinatesInput.value = this.selectedCoordinates;
}

// タップフィードバック
if (navigator.vibrate) navigator.vibrate(100);

// 地図を自動で閉じる
this.closeMapModal();
},

closeMapModal() {
this.showMapModal = false;
if (this.map) {
this.map.remove();
this.map = null;
}
this.mapMarker = null;
},

copyCoordinates() {
const coordinatesInput = document.getElementById('eventCoordinates');
if (!coordinatesInput || !coordinatesInput.value.trim()) {
alert('コピーする緯度経度がありません');
return;
}

const coordinates = coordinatesInput.value.trim();

try {
navigator.clipboard.writeText(coordinates).then(() => {
alert('緯度経度をクリップボードにコピーしました');
if (navigator.vibrate) navigator.vibrate(100);
}).catch(() => {
// フォールバック処理
coordinatesInput.select();
document.execCommand('copy');
alert('緯度経度をクリップボードにコピーしました');
if (navigator.vibrate) navigator.vibrate(100);
});
} catch (error) {
console.error('コピーに失敗しました:', error);
alert('コピーに失敗しました');
}
},

openGoogleMap(coordinates) {
if (!coordinates || !coordinates.trim()) {
alert('緯度経度が設定されていません');
return;
}

const coords = coordinates.trim();
const googleMapsUrl = `https://maps.google.co.jp/maps?ll=${coords}&z=15`;

try {
if (this.isMobile) {
// モバイルの場合はアプリで開く
window.location.href = googleMapsUrl;
} else {
// デスクトップの場合は別タブで開く
window.open(googleMapsUrl, '_blank', 'noopener,noreferrer');
}
} catch (error) {
console.error('Googleマップの表示中にエラーが発生しました:', error);
alert('Googleマップの表示に失敗しました');
}
},

openDetailModal(event) {
const eventData = typeof event === 'string' ? this.events.find(e => String(e.id) === String(event)) : event;
if (!eventData) {
console.error('openDetailModal: 予定データが見つかりません:', event);
alert('予定データが見つかりません');
return;
}
const safeEventId = String(eventData.id).replace(/'/g, "\\'");
const safeTitle = String(eventData.title).replace(/'/g, "\\'").replace(/"/g, "&quot;");
const safeCoordinates = String(eventData.coordinates || '').replace(/"/g, "&quot;");
this.openModal('詳細', `
<div class="mb-3"><h6><i class="${this.getCategoryIcon(eventData.category)}"></i> ${safeTitle}</h6></div>
<div class="mb-3"><strong>日付:</strong> ${this.tripDays[eventData.dayIndex]?.date || '不明'}</div>
<div class="mb-3"><strong>時間:</strong> ${eventData.startTime} - ${eventData.endTime}</div>
${eventData.coordinates ? `<div class="mb-3"><strong>緯度経度:</strong> ${safeCoordinates} <button type="button" class="btn btn-outline-primary btn-sm ms-2" onclick="window.app.openGoogleMap('${safeCoordinates}')" title="Googleマップで表示">🗾</button></div>` : ''}
${eventData.description ? `<div class="mb-3"><strong>詳細:</strong><br>${this.linkifyUrls(String(eventData.description).replace(/"/g, "&quot;"))}</div>` : ''}
`, `
<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
<button type="button" class="btn btn-danger" onclick="window.app.deleteEventFromDetail('${safeEventId}')">削除</button>
<button type="button" class="btn btn-primary" onclick="window.app.editEventFromDetail('${safeEventId}')">編集</button>
`);
},

deleteEventFromDetail(eventId) {
try {
if (!confirm('この予定を削除しますか？')) {
return;
}
const eventIndex = this.events.findIndex(e => String(e.id) === String(eventId));
if (eventIndex === -1) {
alert('予定が見つかりません。ページを再読み込みしてお試しください。');
return;
}
this.events.splice(eventIndex, 1);
this.saveData();
this.editModeEvent = null;
this.closeAllModals();
if (navigator.vibrate) navigator.vibrate(100);
} catch (error) {
console.error('予定の削除中にエラーが発生しました:', error);
alert('予定の削除に失敗しました。もう一度お試しください。');
}
},

editEventFromDetail(eventId) {
try {
const event = this.events.find(e => String(e.id) === String(eventId));
if (!event) {
alert('予定が見つかりません。ページを再読み込みしてお試しください。');
return;
}
this.closeAllModals();
setTimeout(() => {
this.openEventModal(event);
}, 100);
} catch (error) {
console.error('予定の編集準備中にエラーが発生しました:', error);
alert('予定の編集準備に失敗しました。もう一度お試しください。');
}
},

openEventModal(event = null, fromContextMenu = false) {
const isEdit = !!event;
if (isEdit) {
// 編集モード
this.eventForm = { ...event };
} else {
// 新規追加モード
this.eventForm = {
title: '',
dayIndex: this.activeDay,
startTime: '09:00',
endTime: '10:00',
category: 'travel',
description: '',
coordinates: ''
};
}

// モーダルのタイトルと内容を設定
const modalTitle = isEdit ? '予定を編集' : '新しい予定を追加';
const modalBody = this.generateEventModalBody();
const modalFooter = this.generateEventModalFooter(isEdit);

this.openModal(modalTitle, modalBody, modalFooter);
},

generateEventModalBody() {
return `
<div class="mb-3">
<label for="eventTitle" class="form-label">予定タイトル</label>
<input type="text" class="form-control" id="eventTitle" value="${this.eventForm.title.replace(/"/g, '&quot;')}" placeholder="予定のタイトルを入力">
</div>
<div class="mb-3">
<label for="eventDay" class="form-label">日程</label>
<select class="form-select" id="eventDay">
${this.tripDays.map((day, index) => 
`<option value="${index}" ${this.eventForm.dayIndex === index ? 'selected' : ''}>${day.dayNumber}日目 (${day.date})</option>`
).join('')}
</select>
</div>
<div class="row">
<div class="col-md-6">
<div class="mb-3">
<label for="eventStartTime" class="form-label">開始時間</label>
<input type="time" class="form-control" id="eventStartTime" value="${this.eventForm.startTime}" min="04:00" max="23:59">
</div>
</div>
<div class="col-md-6">
<div class="mb-3">
<label for="eventEndTime" class="form-label">終了時間</label>
<input type="time" class="form-control" id="eventEndTime" value="${this.eventForm.endTime}" min="04:00" max="24:00">
</div>
</div>
</div>
<div class="mb-3">
<label for="eventCategory" class="form-label">カテゴリー</label>
<select class="form-select" id="eventCategory">
<option value="travel" ${this.eventForm.category === 'travel' ? 'selected' : ''}>🚗 移動</option>
<option value="food" ${this.eventForm.category === 'food' ? 'selected' : ''}>🍽️ 食事</option>
<option value="sightseeing" ${this.eventForm.category === 'sightseeing' ? 'selected' : ''}>📸 観光</option>
<option value="accommodation" ${this.eventForm.category === 'accommodation' ? 'selected' : ''}>🏨 宿泊</option>
<option value="custom" ${this.eventForm.category === 'custom' ? 'selected' : ''}>⭐ その他</option>
</select>
</div>
<div class="mb-3">
<label for="eventCoordinates" class="form-label">緯度経度 (オプション)</label>
<div class="input-group">
<input type="text" class="form-control" id="eventCoordinates" value="${this.eventForm.coordinates.replace(/"/g, '&quot;')}" placeholder="例: 34.702485,135.495951">
<button class="btn btn-outline-secondary" type="button" onclick="window.app.setLocationFromMap()" title="地図から選択">🗾</button>
<button class="btn btn-outline-secondary" type="button" onclick="window.app.copyCoordinates()" title="コピー">📋</button>
</div>
<div class="form-text">地図から位置を選択するか、緯度,経度の形式で入力してください</div>
</div>
<div class="mb-3">
<label for="eventDescription" class="form-label">詳細 (オプション)</label>
<textarea class="form-control" id="eventDescription" rows="3" placeholder="予定の詳細を入力">${this.eventForm.description.replace(/"/g, '&quot;')}</textarea>
</div>
`;
},

generateEventModalFooter(isEdit) {
return `
<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
<button type="button" class="btn btn-primary" onclick="window.app.saveEvent(${isEdit})">${isEdit ? '更新' : '追加'}</button>
`;
},

saveEvent(isEdit) {
const title = document.getElementById('eventTitle').value.trim();
const dayIndex = parseInt(document.getElementById('eventDay').value);
const startTime = document.getElementById('eventStartTime').value;
const endTime = document.getElementById('eventEndTime').value;
const category = document.getElementById('eventCategory').value;
const coordinates = document.getElementById('eventCoordinates').value.trim();
const description = document.getElementById('eventDescription').value.trim();

if (!title) {
alert('予定タイトルを入力してください');
return;
}

if (!startTime || !endTime) {
alert('開始時間と終了時間を選択してください');
return;
}

if (startTime >= endTime) {
alert('終了時間は開始時間より後に設定してください');
return;
}

// 座標の形式チェック
if (coordinates && !this.validateCoordinates(coordinates)) {
alert('緯度経度の形式が正しくありません。\n正しい形式：34.702485,135.495951');
return;
}

const eventData = {
title,
dayIndex,
startTime,
endTime,
category,
coordinates,
description
};

if (isEdit) {
// 編集の場合
const eventIndex = this.events.findIndex(e => e.id === this.eventForm.id);
if (eventIndex !== -1) {
this.events[eventIndex] = { ...this.events[eventIndex], ...eventData };
}
} else {
// 新規追加の場合
eventData.id = Date.now() + Math.random();
this.events.push(eventData);
}

this.saveData();
this.closeAllModals();
this.editModeEvent = null;

// 追加・編集した日程をアクティブにする
this.activeDay = dayIndex;

// 天気予報を再取得
this.loadWeatherForAllEvents();

if (navigator.vibrate) navigator.vibrate(100);
},

validateCoordinates(coordinates) {
const coordPattern = /^-?\d+\.?\d*,-?\d+\.?\d*$/;
if (!coordPattern.test(coordinates)) return false;

const [lat, lng] = coordinates.split(',').map(Number);
return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
},

openModal(title, body, footer, size = '') {
const modalId = 'modal-' + Date.now();
const modal = {
id: modalId,
title,
body,
footer,
size
};

this.modals.push(modal);

this.$nextTick(() => {
const modalElement = document.getElementById(modalId);
if (modalElement) {
const bootstrapModal = new bootstrap.Modal(modalElement);
bootstrapModal.show();

// モーダルが閉じられたときにmodals配列から削除
modalElement.addEventListener('hidden.bs.modal', () => {
const index = this.modals.findIndex(m => m.id === modalId);
if (index !== -1) {
this.modals.splice(index, 1);
}
});
}
});
},

closeAllModals() {
this.modals.forEach(modal => {
const modalElement = document.getElementById(modal.id);
if (modalElement) {
const bootstrapModal = bootstrap.Modal.getInstance(modalElement);
if (bootstrapModal) {
bootstrapModal.hide();
}
}
});
this.modals = [];
},

openStartDateModal() {
this.openModal('開始日を変更', `
<div class="mb-3">
<label for="newStartDate" class="form-label">新しい開始日</label>
<input type="date" class="form-control" id="newStartDate" value="${this.tripDays[0].fullDate}" min="${this.today}">
</div>
<div class="alert alert-warning">
<i class="fas fa-exclamation-triangle"></i>
<strong>注意:</strong> 開始日を変更すると、既存の予定の日程も自動的に調整されます。
</div>
`, `
<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
<button type="button" class="btn btn-primary" onclick="window.app.updateStartDate()">変更</button>
`);
},

updateStartDate() {
const newStartDate = document.getElementById('newStartDate').value;
if (!newStartDate) {
alert('新しい開始日を選択してください');
return;
}

if (newStartDate < this.today) {
alert('開始日は今日以降の日付を選択してください');
return;
}

if (confirm('開始日を変更しますか？既存の予定も日程が調整されます。')) {
this.tripDays = this.generateConsecutiveDays(newStartDate, this.tripDays.length);
this.saveData();
this.closeAllModals();
// 天気予報を再取得
this.loadWeatherForAllEvents();
if (navigator.vibrate) navigator.vibrate(100);
}
},

// レイヤー順序の保存
saveLayerOrder() {
localStorage.setItem('trippenLayerOrder', JSON.stringify(this.eventLayerOrder));
localStorage.setItem('trippenMaxZIndex', this.maxZIndex.toString());
},

// レイヤー順序の読み込み
loadLayerOrder() {
const savedLayerOrder = localStorage.getItem('trippenLayerOrder');
const savedMaxZIndex = localStorage.getItem('trippenMaxZIndex');

if (savedLayerOrder) {
try {
this.eventLayerOrder = JSON.parse(savedLayerOrder);
} catch (e) {
console.error('レイヤー順序データの読み込みに失敗しました:', e);
this.eventLayerOrder = [];
}
}

if (savedMaxZIndex) {
this.maxZIndex = parseInt(savedMaxZIndex) || this.baseZIndex;
}
},

// saveDataメソッドの修正
saveData() {
localStorage.setItem('trippenEvents', JSON.stringify(this.events));
localStorage.setItem('trippenDays', JSON.stringify(this.tripDays));
this.saveLayerOrder();
},

// loadDataメソッドの修正
loadData() {
const savedEvents = localStorage.getItem('trippenEvents');
const savedDays = localStorage.getItem('trippenDays');

if (savedEvents) {
try {
this.events = JSON.parse(savedEvents);
} catch (e) {
console.error('予定データの読み込みに失敗しました:', e);
this.events = [];
}
}

if (savedDays) {
try {
this.tripDays = JSON.parse(savedDays);
} catch (e) {
console.error('日程データの読み込みに失敗しました:', e);
this.tripDays = [];
}
}

// レイヤー順序の読み込み
this.loadLayerOrder();
}
},
mounted() {
this.detectMobile();
this.checkExistingData();
this.loadData();
if (this.tripDays.length > 0) {
this.tripInitialized = true;
// 天気予報を読み込む
this.loadWeatherForAllEvents();
}
window.addEventListener('resize', this.detectMobile);
window.app = this;
}
}).mount('#app');
</script>
</body>
</html>

