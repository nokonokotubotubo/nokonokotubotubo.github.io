<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>とりっぺんちゃん - 旅行予定調整サイト</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<!-- Leafletライブラリ（OpenStreetMap API用）-->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
:root{--primary:#87CEEB;--secondary:#B0E0E6;--accent:#4682B4;--text:#2F4F4F;--bg:#F0F8FF;--time-bg:#E6F3FF;--transition:all 0.3s ease;--radius:15px;--shadow:0 2px 10px rgba(0,0,0,0.1)}
*{box-sizing:border-box}
html,body{height:100%;overflow:hidden;margin:0;padding:0}
body{background:var(--bg);color:var(--text);font-family:system-ui,sans-serif;display:flex;flex-direction:column}
#app{height:100vh;display:flex;flex-direction:column;overflow:hidden}
.header{background:linear-gradient(135deg,var(--primary),var(--secondary));color:white;padding:8px 0;text-align:center;box-shadow:var(--shadow);flex-shrink:0;position:relative}
.header .container{position:relative}
.header h1{margin:0;display:inline-block}
.cloud-load-btn{position:absolute;left:15px;top:50%;transform:translateY(-50%);background:none;border:none;color:white;font-size:1.5rem;cursor:pointer;padding:8px;border-radius:50%;transition:var(--transition);z-index:100}
.cloud-load-btn:hover{background:rgba(255,255,255,0.2);color:white}
.cloud-load-btn:disabled{opacity:0.5;cursor:not-allowed}
.cloud-load-btn.loading{animation:spin 1s linear infinite}
.cloud-load-btn.error{color:#ff6b6b}
.cloud-write-btn{position:absolute;left:65px;top:50%;transform:translateY(-50%);background:none;border:none;color:white;font-size:1.5rem;cursor:pointer;padding:8px;border-radius:50%;transition:var(--transition);z-index:100}
.cloud-write-btn:hover{background:rgba(255,255,255,0.2);color:white}
.cloud-write-btn:disabled{opacity:0.5;cursor:not-allowed}
.cloud-write-btn.loading{animation:spin 1s linear infinite}
.cloud-write-btn.error{color:#ff6b6b}
@keyframes spin{0%{transform:translateY(-50%) rotate(0deg)}100%{transform:translateY(-50%) rotate(360deg)}}
.settings-btn{position:absolute;right:15px;top:50%;transform:translateY(-50%);background:none;border:none;color:white;font-size:1.5rem;cursor:pointer;padding:8px;border-radius:50%;transition:var(--transition);z-index:100}
.settings-btn:hover{background:rgba(255,255,255,0.2);color:white}
.penguin-icon{font-size:2rem;margin-right:10px}
.desktop-ui,.mobile-ui{flex:1;display:flex;flex-direction:column;overflow:hidden}
.day-tabs-container{overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--secondary) transparent;flex-shrink:0}
.day-tabs{background:white;border-radius:var(--radius) var(--radius) 0 0;margin:10px 0 0 0;box-shadow:var(--shadow);display:flex;min-width:max-content}
.day-tabs .nav-item{transition:var(--transition);flex-shrink:0;position:relative}
.day-tabs .nav-link{border:none;color:var(--text);padding:12px 20px;line-height: 1.2;border-radius:var(--radius) var(--radius) 0 0;white-space:nowrap;text-align:center;min-width:120px;transition:var(--transition);position:relative;display:block}
.day-tabs .nav-link.active{background:var(--primary);color:white;box-shadow:var(--shadow)}
.day-tabs .nav-link:hover{background:var(--secondary);color:white}
.delete-day-btn{position:absolute;top:5px;right:5px;width:20px;height:20px;border-radius:50%;background:rgba(255,99,99,0.8);color:white;border:none;font-size:0.7rem;display:none;align-items:center;justify-content:center;cursor:pointer;transition:var(--transition)}
.delete-day-btn:hover{background:rgba(255,99,99,1);transform:scale(1.1)}
.day-tabs .nav-link:hover .delete-day-btn{display:flex}
.mobile-day-selector{background:white;padding:12px 0;box-shadow:var(--shadow);flex-shrink:0;position:relative}
.mobile-scroll-container{position:relative;padding:0 50px}
.mobile-day-buttons{display:flex;gap:10px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--secondary) transparent;padding:0 15px 10px 15px}
.mobile-day-btn{min-width:100px;height:60px;border:2px solid var(--secondary);background:white;border-radius:var(--radius);display:flex;flex-direction:column;align-items:center;justify-content:center;font:bold 0.9rem/1 sans-serif;color:var(--text);transition:var(--transition);flex-shrink:0;-webkit-tap-highlight-color:transparent;user-select:none;touch-action:manipulation}
.mobile-day-btn.active{background:var(--primary);color:white;border-color:var(--primary)}
.mobile-day-btn:active{transform:scale(0.95)}
.mobile-scroll-nav{position:absolute;top:50%;transform:translateY(-50%);width:40px;height:40px;border-radius:50%;background:rgba(255,255,255,0.9);border:2px solid var(--secondary);color:var(--accent);font-size:1rem;cursor:pointer;transition:var(--transition);z-index:10;display:flex;align-items:center;justify-content:center;box-shadow:var(--shadow)}
.mobile-scroll-nav:active{transform:translateY(-50%) scale(0.9)}
.mobile-scroll-nav.left{left:5px}
.mobile-scroll-nav.right{right:5px}
.mobile-scroll-nav.disabled{opacity:0.3;pointer-events:none}
.mobile-popup-menu{position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:2000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;transition:var(--transition);-webkit-tap-highlight-color:transparent}
.mobile-popup-menu.show{opacity:1;visibility:visible}
.mobile-popup-content{background:white;border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,0.3);max-width:300px;width:90%;text-align:center}
.mobile-popup-title{font:bold 1.2rem/1 sans-serif;color:var(--accent);margin-bottom:20px}
.mobile-popup-buttons{display:flex;flex-direction:column;gap:15px}
.mobile-popup-btn{padding:15px 20px;border:none;border-radius:var(--radius);font:bold 1rem/1 sans-serif;cursor:pointer;transition:var(--transition);display:flex;align-items:center;justify-content:center;gap:10px;-webkit-tap-highlight-color:transparent;touch-action:manipulation}
.mobile-popup-btn.primary{background:var(--primary);color:white}
.mobile-popup-btn.success{background:#28a745;color:white}
.mobile-popup-btn.danger{background:#dc3545;color:white}
.mobile-popup-btn.secondary{background:#6c757d;color:white}
.mobile-popup-btn:active{transform:scale(0.95)}
.mobile-fab{position:fixed;bottom:20px;right:20px;width:60px;height:60px;border-radius:50%;background:var(--accent);border:none;color:white;font-size:1.5rem;box-shadow:0 4px 15px rgba(0,0,0,0.3);transition:var(--transition);z-index:1000;-webkit-tap-highlight-color:transparent}
.mobile-fab:active{transform:scale(0.9)}
.timeline-container{background:white;border-radius:0 0 var(--radius) var(--radius);margin:0;box-shadow:0 4px 15px rgba(0,0,0,0.1);flex:1;display:flex;flex-direction:column;overflow:hidden}
.timeline-header{background:var(--secondary);padding:8px 20px;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.timeline-header h5{font-size:1rem;margin:0;line-height:1.2}.timeline-header h5 small{font-size:0.85rem;margin-left:8px}
.timeline-content{flex:1;overflow:hidden}
.timeline-scroll-container{height:100%;display:flex;overflow-y:auto;overflow-x:hidden}
.time-axis{width:80px;background:var(--time-bg);border-right:2px solid var(--secondary);flex-shrink:0;height:1200px}
.time-slot{height:60px;display:flex;align-items:center;justify-content:center;font:bold 0.9rem/1 sans-serif;color:var(--text);border-bottom:1px solid #e0e0e0}
.schedule-area{flex:1;position:relative;height:1200px}
.schedule-grid{position:absolute;inset:0;height:1200px}
.grid-line{height:60px;border-bottom:1px solid #e0e0e0;position:relative}
.grid-line:nth-child(odd){background:rgba(135,206,235,0.05)}
.quarter-line{position:absolute;left:0;right:0;height:1px;background:#f0f0f0}
.quarter-line:nth-child(1){top:15px}
.quarter-line:nth-child(2){top:30px}
.quarter-line:nth-child(3){top:45px}
.event-block{position:absolute;left:10px;right:10px;background:var(--primary);color:white;border-radius:8px;padding:8px 12px 8px 25px;box-shadow:0 2px 8px rgba(0,0,0,0.2);border:2px solid transparent;transition:var(--transition);z-index:10;user-select:none;-webkit-tap-highlight-color:transparent;min-height:35px;display:flex;align-items:center}
.event-block:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);border-color:var(--accent)}
.event-block.edit-mode{border-color:#FFD700;box-shadow:0 0 0 3px rgba(255,215,0,0.3);cursor:grab}
.event-block.edit-mode:active{cursor:grabbing}
.event-block.ready-to-move{border-color:#4CAF50;box-shadow:0 0 0 3px rgba(76,175,80,0.4);transform:scale(1.05);background:linear-gradient(45deg,rgba(76,175,80,0.1),transparent,rgba(76,175,80,0.1));animation:readyToPulse 1.5s infinite ease-in-out}
@keyframes readyToPulse{0%,100%{box-shadow:0 0 0 3px rgba(76,175,80,0.4)}50%{box-shadow:0 0 0 6px rgba(76,175,80,0.2)}}
.event-block.ready-to-move::before{content:"↕";position:absolute;top:50%;right:8px;transform:translateY(-50%);font-size:1.2rem;color:#4CAF50;font-weight:bold;z-index:25;animation:bounceIcon 1s infinite ease-in-out}
@keyframes bounceIcon{0%,100%{transform:translateY(-50%) scale(1)}50%{transform:translateY(-50%) scale(1.2)}}
.event-block.dragging{z-index:1000;opacity:0.8;transform:scale(1.02)}
.event-block.dragging .event-actions{display:none!important}
.event-block.layered{/* 動的にz-indexが設定される */}
.event-content-inline{font-size:0.9rem;line-height:1.2;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;font-weight:bold}
.event-title,.event-time,.event-description{display:none}
.event-category-travel{background:#FF6B6B}
.event-category-food{background:#4ECDC4}
.event-category-sightseeing{background:#45B7D1}
.event-category-accommodation{background:#96CEB4}
.event-category-custom{background:#FECA57}
.event-actions{position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);display:flex;gap:5px;z-index:20}
.event-action-btn{width:30px;height:30px;border-radius:8px;border:none;color:white;font-size:0.8rem;cursor:pointer;transition:var(--transition);display:flex;align-items:center;justify-content:center;box-shadow:0 2px 6px rgba(0,0,0,0.3);touch-action:manipulation;-webkit-tap-highlight-color:transparent}
.event-action-btn.cut{background:#FF6B6B;border:2px solid #fff}
.event-action-btn.cut:hover{background:#FF5252;transform:scale(1.1)}
.context-menu{position:fixed;background:white;border:1px solid #ddd;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.2);z-index:2000;opacity:0;visibility:hidden;transform:scale(0.8);transition:var(--transition);min-width:150px}
.context-menu.show{opacity:1;visibility:visible;transform:scale(1)}
.context-menu-item{padding:12px 16px;cursor:pointer;border-bottom:1px solid #eee;transition:var(--transition);display:flex;align-items:center;gap:8px}
.context-menu-item:last-child{border-bottom:none}
.context-menu-item:hover{background:#f5f5f5}
.context-menu-item.paste{color:#4CAF50}
.context-menu-item.paste:hover{背景:#e8f5e8}
.context-menu-item.add-event{color:#4CAF50}
.context-menu-item.add-event:hover{background:#e8f5e8}
.context-menu-item.disabled{color:#ccc;cursor:not-allowed}
.context-menu-item.disabled:hover{background:transparent}
.resize-handle{position:absolute;left:0;right:0;height:10px;background:rgba(255,215,0,0.8);opacity:0;transition:var(--transition);cursor:ns-resize}
.resize-handle.top{top:0;border-radius:8px 8px 0 0}
.resize-handle.bottom{bottom:0;border-radius:0 0 8px 8px}
.event-block.edit-mode .resize-handle{opacity:1}
.modal-content{border-radius:var(--radius);border:none;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
.modal-header{background:var(--primary);color:white;border-radius:var(--radius) var(--radius) 0 0}
.btn-primary{background:var(--accent);border:none;border-radius:20px;padding:8px 20px;transition:var(--transition)}
.btn-primary:hover{background:var(--text);transform:translateY(-2px)}
.form-control{border-radius:10px;border:2px solid #e0e0e0;transition:var(--transition)}
.form-control:focus{border-color:var(--primary);box-shadow:0 0 0 0.2rem rgba(135,206,235,0.25)}
.add-event-btn{position:fixed;bottom:30px;right:30px;width:60px;height:60px;border-radius:50%;background:var(--accent);border:none;color:white;font-size:1.5rem;box-shadow:0 4px 15px rgba(0,0,0,0.3);transition:var(--transition);z-index:1000}
.add-event-btn:hover{transform:scale(1.1);background:var(--primary)}
.trip-setup{text-align:center;padding:40px 20px}
.trip-setup h2{color:var(--accent);margin-bottom:30px}
.date-input-group{display:flex;align-items:center;justify-content:center;gap:15px;margin:20px 0;flex-wrap:wrap}
.date-input-group input[type="date"]{padding:10px;border:2px solid var(--secondary);border-radius:8px;font-size:1rem}
.date-input-group span{font:bold 1.2rem/1 sans-serif;color:var(--accent)}
.weather-emoji-top-left {position: absolute;top: -12px;left:-12px;font-size: 2rem;z-index: 30;line-height: 1;cursor: pointer;-webkit-tap-highlight-color: transparent;}
.map-modal {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: rgba(0, 0, 0, 0.8);z-index: 3000;display: flex;align-items: center;justify-content: center;}
.map-container {width: 90%;max-width: 800px;height: 80%;max-height: 600px;background: white;border-radius: 10px;position: relative;overflow: hidden;}
.map-header {background: var(--primary);color: white;padding: 15px;display: flex;justify-content: space-between;align-items: center;}.map-close-btn {background: none;border: none;color: white;font-size: 1.5rem;cursor: pointer;width: 30px;height: 30px;display: flex;align-items: center;justify-content: center;border-radius: 50%;transition: background 0.3s;}
.map-close-btn:hover {background: rgba(255, 255, 255, 0.2);}
#map {width: 100%;height: calc(100% - 60px);}
.map-info {position: absolute;bottom: 10px;left: 10px;right: 10px;background: rgba(255, 255, 255, 0.9);padding: 10px;border-radius: 5px;font-size: 0.9rem;text-align: center;}
.weather-popup-modal {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0, 0, 0, 0.7);z-index: 5000;display: flex;align-items: center;justify-content: center;}
.weather-popup-content {width: 100%;height: 100%;background: #fff;position: relative;}
.weather-popup-close {position: absolute;top: 10px;right: 15px;width: 40px;height: 40px;border-radius: 50%;background: rgba(0,0,0,0.5);border: 2px solid white;color: white;font-size: 2rem;line-height: 36px;text-align: center;cursor: pointer;z-index: 5001;padding: 0;-webkit-appearance: none;}
.weather-popup-close:hover {background: rgba(0,0,0,0.8);}
.weather-popup-iframe {width: 100%;height: 100%;border: none;}
.settings-modal {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: rgba(0, 0, 0, 0.8);z-index: 4000;display: flex;align-items: center;justify-content: center;opacity: 0;visibility: hidden;transition: var(--transition);}
.settings-modal.show {opacity: 1;visibility: visible;}
.settings-content {background: white;border-radius: var(--radius);width: 90%;max-width: 600px;max-height: 80vh;overflow-y: auto;box-shadow: 0 10px 30px rgba(0,0,0,0.3);}
.settings-header {background: var(--primary);color: white;padding: 20px;border-radius: var(--radius) var(--radius) 0 0;display: flex;justify-content: space-between;align-items: center;}
.settings-header h2 {margin: 0;font-size: 1.5rem;}
.settings-close {background: none;border: none;color: white;font-size: 1.5rem;cursor: pointer;padding: 5px;border-radius: 50%;width: 35px;height: 35px;display: flex;align-items: center;justify-content: center;transition: var(--transition);}
.settings-close:hover {background: rgba(255, 255, 255, 0.2);}
.settings-body {padding: 20px;}
.settings-section {margin-bottom: 30px;}
.settings-section h3 {color: var(--accent);margin-bottom: 15px;font-size: 1.2rem;}
.settings-section p {color: #666;margin-bottom: 15px;line-height: 1.5;}
.sync-status {background: #f8f9fa;padding: 15px;border-radius: 8px;margin-bottom: 15px;border-left: 4px solid var(--primary);}
.sync-status.disabled {border-left-color: #6c757d;}
.sync-status.error {border-left-color: #dc3545;}
.sync-actions {display: flex;gap: 10px;flex-wrap: wrap;margin-top: 15px;}
.sync-btn {padding: 10px 20px;border: none;border-radius: 8px;cursor: pointer;font-size: 0.9rem;transition: var(--transition);text-decoration: none;display: inline-block;text-align: center;}
.sync-btn.primary {background: var(--primary);color: white;}
.sync-btn.primary:hover {background: var(--accent);color: white;}
.sync-btn.success {background: #28a745;color: white;}
.sync-btn.success:hover {background: #218838;}
.sync-btn.danger {background: #dc3545;color: white;}
.sync-btn.danger:hover {background: #c82333;}
.sync-btn.secondary {background: #6c757d;color: white;}
.sync-btn.secondary:hover {background: #5a6268;}
.form-group {margin-bottom: 20px;}
.form-group label {display: block;margin-bottom: 8px;font-weight: 600;color: var(--text);}
.form-group input {width: 100%;padding: 10px;border: 2px solid #e0e0e0;border-radius: 8px;font-size: 1rem;transition: var(--transition);}
.form-group input:focus {border-color: var(--primary);box-shadow: 0 0 0 0.2rem rgba(135,206,235,0.25);outline: none;}
.conflict-modal {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: rgba(0, 0, 0, 0.8);z-index: 6000;display: flex;align-items: center;justify-content: center;opacity: 0;visibility: hidden;transition: var(--transition);}
.conflict-modal.show {opacity: 1;visibility: visible;}
.conflict-content {background: white;border-radius: var(--radius);width: 90%;max-width: 500px;padding: 0;box-shadow: 0 10px 30px rgba(0,0,0,0.3);}
.conflict-header {background: #dc3545;color: white;padding: 20px;border-radius: var(--radius) var(--radius) 0 0;text-align: center;}
.conflict-body {padding: 20px;text-align: center;line-height: 1.6;}
.conflict-actions {padding: 0 20px 20px 20px;display: flex;gap: 10px;flex-direction: column;}
.conflict-btn {padding: 15px;border: none;border-radius: 8px;font-weight: bold;cursor: pointer;transition: var(--transition);}
.conflict-btn.primary {background: var(--primary);color: white;}
.conflict-btn.secondary {background: #6c757d;color: white;}
.conflict-btn:hover {transform: translateY(-2px);box-shadow: 0 4px 8px rgba(0,0,0,0.2);}
@media (max-width:768px){
.header{padding:6px 0}
.cloud-load-btn{left:10px;font-size:1.3rem}
.cloud-write-btn{left:55px;font-size:1.3rem}
.settings-btn{right:10px;font-size:1.3rem}
.timeline-header{padding:6px 15px}
.timeline-header h5{font-size:0.9rem}
.timeline-header h5 small{font-size:0.75rem;display:block;margin-left:0;margin-top:2px}
.day-tabs{margin:8px 0 0 0}
.time-axis{width:60px;height:1000px}
.time-slot{height:50px;font-size:0.8rem}
.grid-line{height:50px}
.schedule-grid,.schedule-area{height:1000px}
.event-block{padding:6px 8px 6px 22px;min-height:32px}
.event-content-inline{font-size:0.8rem}
.date-input-group{flex-direction:column;gap:10px}
.event-action-btn{width:35px;height:35px;font-size:0.9rem}
.event-block.overlapping{opacity:0.7;border:2px solid #ff6b6b}
.weather-emoji-top-left{font-size:1.5rem}
.settings-content{width:95%;max-height:90vh}
.settings-header{padding:15px}
.settings-body{padding:15px}
.sync-actions{flex-direction:column}
.sync-btn{width:100%}
.conflict-content{width:95%}
}
</style>
</head>
<body>
<div id="app">
<header class="header">
<div class="container">
<button class="cloud-load-btn" @click="loadFromCloud" title="クラウドから読込" :disabled="gistSync.isLoading" :class="{ loading: gistSync.isLoading, error: gistSync.hasError }">
<i class="fas fa-cloud-download-alt"></i>
</button>
<button class="cloud-write-btn" @click="manualSync" title="手動書き込み" :disabled="gistSync.isSyncing" :class="{ loading: gistSync.isSyncing, error: gistSync.hasError }">
<i class="fas fa-cloud-upload-alt"></i>
</button>
<h1><i class="fas fa-snowflake penguin-icon"></i>とりっぺんちゃん</h1>
<button class="settings-btn" @click="openSettingsModal" title="設定">
<i class="fas fa-cog"></i>
</button>
</div>
</header>

<!-- 以降のUIは元のまま（省略なしで全文） -->
<div v-if="!tripInitialized" class="container">
  <div class="trip-setup">
    <h2><i class="fas fa-calendar-alt"></i> 旅行日程を設定</h2>
    <div class="date-input-group">
      <label for="startDate"><strong>開始日:</strong></label>
      <input type="date" id="startDate" v-model="tripStartDate" :min="today">
      <span>〜</span>
      <label for="endDate"><strong>終了日:</strong></label>
      <input type="date" id="endDate" v-model="tripEndDate" :min="tripStartDate">
    </div>
    <div class="mt-4">
      <button class="btn btn-primary btn-lg" @click="initializeTripDays" :disabled="!tripStartDate || !tripEndDate">
        <i class="fas fa-check"></i> 旅行スケジュールを作成
      </button>
    </div>
    <div class="mt-3">
      <button class="btn btn-outline-secondary" @click="loadExistingData" v-if="hasExistingData">
        <i class="fas fa-folder-open"></i> 既存のデータを読み込む
      </button>
    </div>
  </div>
</div>

<!-- デスクトップUI -->
<div v-if="tripInitialized && !isMobile" class="desktop-ui">
  <div class="day-tabs-container">
    <ul class="nav nav-tabs day-tabs">
      <li class="nav-item" v-for="(day, index) in tripDays" :key="`day-${day.id || index}`">
        <a class="nav-link" :class="{ active: activeDay === index }" @click="setActiveDay(index)" href="#" @click.prevent>
          <div>
            <div>{{ day.dayNumber }}日目</div>
            <small :class="{ 'editable-date': index === 0 }">
              {{ day.date }}
              <i v-if="index === 0" class="fas fa-edit" @click.stop="handleDateClick(index)" style="cursor: pointer; margin-left: 4px; padding: 2px; border-radius: 3px; transition: background 0.2s;" @mouseover="$event.target.style.background='rgba(255,255,255,0.2)'" @mouseout="$event.target.style.background='transparent'" title="開始日を変更"></i>
            </small>
          </div>
          <button class="delete-day-btn" v-if="tripDays.length > 1" @click.stop.prevent="deleteDay(index)" @mousedown.stop title="日程を削除">
            <i class="fas fa-times"></i>
          </button>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link add-day-btn" @click.prevent.stop="addDayImmediately" @mousedown.stop href="#" title="日程を追加">
          <div>
            <div style="font-size: 1.5rem; font-weight: bold;">＋</div>
            <small style="visibility: hidden;">日程追加</small>
          </div>
        </a>
      </li>
    </ul>
  </div>
  <div class="timeline-container">
    <div class="timeline-header">
      <h5>
        <i class="fas fa-calendar-day"></i>
        {{ tripDays[activeDay]?.dayNumber }}日目の予定
        <small class="text-muted">{{ tripDays[activeDay]?.date }}</small>
      </h5>
    </div>
    <div class="timeline-content">
      <div class="timeline-scroll-container" ref="scrollContainer">
        <div class="time-axis">
          <div class="time-slot" v-for="hour in timeSlots" :key="hour">
            {{ hour }}:00
          </div>
        </div>
        <div class="schedule-area" @click="editModeEvent = null" @contextmenu="handleScheduleContextMenu">
          <div class="schedule-grid">
            <div class="grid-line" v-for="hour in timeSlots" :key="hour">
              <div class="quarter-line"></div>
              <div class="quarter-line"></div>
              <div class="quarter-line"></div>
            </div>
          </div>
          <div class="event-block" v-for="event in getCurrentDayEvents()" :key="event.id" :class="[
            'event-category-' + event.category,
            { 'edit-mode': editModeEvent && editModeEvent.id === event.id },
            { 'dragging': draggingEvent && draggingEvent.id === event.id },
            { 'ready-to-move': readyToMoveEventId === event.id }
          ]" :style="getEventStyle(event)" @contextmenu.prevent="handleEventContextMenu($event, event)" @click="handleEventClick($event, event)" @mousedown="handleEventMouseDown($event, event)">
            <div class="event-content-inline">
              <i :class="getCategoryIcon(event.category)"></i>
              {{ event.inlineText }}
            </div>
            <span class="weather-emoji-top-left" v-if="getEventWeatherEmoji(event)" @click.stop="openWeatherPopup(event)" title="天気詳細を見る">
              {{ getEventWeatherEmoji(event) }}
            </span>
            <div class="event-actions" v-if="editModeEvent && editModeEvent.id === event.id">
              <button class="event-action-btn cut" @click="handleCutButtonClick($event, event)" @mousedown.stop title="切り取り">
                <i class="fas fa-cut"></i>
              </button>
            </div>
            <div class="resize-handle top" v-if="editModeEvent && editModeEvent.id === event.id" @mousedown="startResize($event, event, 'top')"></div>
            <div class="resize-handle bottom" v-if="editModeEvent && editModeEvent.id === event.id" @mousedown="startResize($event, event, 'bottom')"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- モバイルUI -->
<div v-if="tripInitialized && isMobile" class="mobile-ui">
  <div class="mobile-day-selector">
    <div class="mobile-scroll-container">
      <button class="mobile-scroll-nav left" :class="{ disabled: scrollPosition <= 0 }" @click="scrollToDirection('left')">
        <i class="fas fa-chevron-left"></i>
      </button>
      <div class="mobile-day-buttons" ref="mobileScrollContainer" @scroll="updateScrollPosition">
        <button v-for="(day, index) in tripDays" :key="`mobile-day-${day.id || index}`" class="mobile-day-btn" :class="{ active: activeDay === index }" @click="setActiveDay(index)" @touchstart="handleMobileDayTouchStart($event, index)" @touchend="handleMobileDayTouchEnd($event, index)">
          <div>{{ day.dayNumber }}日目</div>
          <small>{{ day.date }}</small>
        </button>
      </div>
      <button class="mobile-scroll-nav right" :class="{ disabled: scrollPosition >= maxScrollPosition }" @click="scrollToDirection('right')">
        <i class="fas fa-chevron-right"></i>
      </button>
    </div>
  </div>
  <div class="timeline-container">
    <div class="timeline-header">
      <h5>
        <i class="fas fa-calendar-day"></i>
        {{ tripDays[activeDay]?.dayNumber }}日目の予定
        <small class="text-muted">{{ tripDays[activeDay]?.date }}</small>
      </h5>
    </div>
    <div class="timeline-content">
      <div class="timeline-scroll-container" ref="mobileTimelineContainer">
        <div class="time-axis">
          <div class="time-slot" v-for="hour in timeSlots" :key="hour">
            {{ hour }}:00
          </div>
        </div>
        <div class="schedule-area" @click="editModeEvent = null" @touchstart="handleScheduleTouchStart" @touchend="handleScheduleTouchEnd" @touchmove="handleScheduleTouchMove">
          <div class="schedule-grid">
            <div class="grid-line" v-for="hour in timeSlots" :key="hour">
              <div class="quarter-line"></div>
              <div class="quarter-line"></div>
              <div class="quarter-line"></div>
            </div>
          </div>
          <div class="event-block" v-for="event in getCurrentDayEvents()" :key="event.id" :class="[
            'event-category-' + event.category,
            { 'edit-mode': editModeEvent && editModeEvent.id === event.id },
            { 'dragging': draggingEvent && draggingEvent.id === event.id },
            { 'ready-to-move': readyToMoveEventId === event.id }
          ]" :style="getEventStyle(event)" @click="handleEventClick($event, event)" @touchstart="handleEventTouchStart($event, event)">
            <div class="event-content-inline">
              <i :class="getCategoryIcon(event.category)"></i>
              {{ event.inlineText }}
            </div>
            <span class="weather-emoji-top-left" v-if="getEventWeatherEmoji(event)" @click.stop="openWeatherPopup(event)" title="天気詳細を見る">
              {{ getEventWeatherEmoji(event) }}
            </span>
            <div class="event-actions" v-if="editModeEvent && editModeEvent.id === event.id">
              <button class="event-action-btn cut" @click="handleCutButtonClick($event, event)" @touchstart.stop title="切り取り">
                <i class="fas fa-cut"></i>
              </button>
            </div>
            <div class="resize-handle top" v-if="editModeEvent && editModeEvent.id === event.id" @touchstart="startResizeTouch($event, event, 'top')"></div>
            <div class="resize-handle bottom" v-if="editModeEvent && editModeEvent.id === event.id" @touchstart="startResizeTouch($event, event, 'bottom')"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <button class="mobile-fab" @click="openEventModal()">
    <i class="fas fa-plus"></i>
  </button>
</div>

<div class="context-menu" :class="{ show: showContextMenu }" :style="contextMenuStyle">
  <div class="context-menu-item add-event" @click="() => addEventFromContext()">
    <i class="fas fa-plus"></i>新しい予定を追加
  </div>
  <div class="context-menu-item paste" :class="{ disabled: !clipboardEvent }" @click="pasteFromContext" v-if="clipboardEvent">
    <i class="fas fa-paste"></i>貼り付け
  </div>
  <div class="context-menu-item disabled" v-else>
    <i class="fas fa-paste"></i>貼り付け（コピー済みアイテムなし）
  </div>
</div>

<!-- 各種モーダル -->
<div class="mobile-popup-menu" :class="{ show: showMobilePopup }" @click="closeMobilePopup" v-if="isMobile">
  <div class="mobile-popup-content" @click.stop>
    <div class="mobile-popup-title">{{ selectedDayForPopup ? `${selectedDayForPopup.dayNumber}日目の編集` : '日程編集' }}</div>
    <div class="mobile-popup-buttons">
      <button class="mobile-popup-btn primary" v-if="selectedDayForPopup && selectedDayIndex === 0" @click="openStartDateModalFromPopup">
        <i class="fas fa-calendar-edit"></i>開始日を変更
      </button>
      <button class="mobile-popup-btn success" @click="addDayFromPopup">
        <i class="fas fa-plus"></i>日程を追加
      </button>
      <button class="mobile-popup-btn danger" v-if="selectedDayForPopup && tripDays.length > 1" @click="deleteDayFromPopup">
        <i class="fas fa-trash"></i>この日程を削除
      </button>
      <button class="mobile-popup-btn secondary" @click="closeMobilePopup">
        <i class="fas fa-times"></i>キャンセル
      </button>
    </div>
  </div>
</div>

<div v-if="showMapModal" class="map-modal" @click="closeMapModal">
  <div class="map-container" @click.stop>
    <div class="map-header">
      <h5><i class="fas fa-map-marker-alt"></i> 位置を選択</h5>
      <button class="map-close-btn" @click="closeMapModal">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div id="map"></div>
    <div class="map-info">
      <i class="fas fa-info-circle"></i> 地図上をタップして位置を選択してください
      <div v-if="selectedCoordinates" class="mt-2">
        <strong>選択した座標:</strong> {{ selectedCoordinates }}
      </div>
    </div>
  </div>
</div>

<div v-if="showWeatherPopup" class="weather-popup-modal">
  <div class="weather-popup-content">
    <button class="weather-popup-close" @click="closeWeatherPopup" title="閉じる">&times;</button>
    <iframe :src="weatherPopupUrl" class="weather-popup-iframe" frameborder="0"></iframe>
  </div>
</div>

<div v-if="showConflictModal" class="conflict-modal" :class="{ show: showConflictModal }" @click="closeConflictModal">
  <div class="conflict-content" @click.stop>
    <div class="conflict-header">
      <h3><i class="fas fa-exclamation-triangle"></i> データ競合が発生</h3>
    </div>
    <div class="conflict-body">
      <p>他の端末でデータが更新されています。</p>
      <p><strong>クラウドから読み込んで最新データに更新しますか？</strong></p>
      <small class="text-muted">※ローカルの変更は失われる可能性があります</small>
    </div>
    <div class="conflict-actions">
      <button class="conflict-btn primary" @click="forceLoadFromCloud">
        <i class="fas fa-cloud-download-alt"></i> クラウドデータで上書き
      </button>
      <button class="conflict-btn secondary" @click="closeConflictModal">
        <i class="fas fa-times"></i> キャンセル（後で同期）
      </button>
    </div>
  </div>
</div>

<div v-if="showSettingsModal" class="settings-modal" :class="{ show: showSettingsModal }" @click="closeSettingsModal">
  <div class="settings-content" @click.stop>
    <div class="settings-header">
      <h2><i class="fas fa-cog"></i> 設定</h2>
      <button class="settings-close" @click="closeSettingsModal">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="settings-body">
      <div class="settings-section">
        <h3><i class="fas fa-cloud-upload-alt"></i> GitHub同期設定</h3>
        <p>GitHub Personal Access Tokenを設定すると、旅行データが自動同期されます。<br>
        <strong>新方式:</strong> ETag条件付き更新 + 高頻度ポーリング + 412時の自動マージ（LWW）</p>
        
        <div class="sync-status" :class="{ disabled: !gistSync.isEnabled, error: gistSync.hasError }">
          <div v-if="gistSync.isEnabled">
            <strong>同期状態:</strong> 有効<br>
            <span v-if="gistSync.gistId">Gist ID: {{ gistSync.gistId }}</span><br>
            <span v-if="gistSync.lastReadTime">最終読込: {{ formatSyncTime(gistSync.lastReadTime) }}</span><br>
            <span v-if="gistSync.lastSyncTime">最終書込: {{ formatSyncTime(gistSync.lastSyncTime) }}</span>
          </div>
          <div v-else>
            <strong>同期状態:</strong> 無効<br>
            <span>GitHub同期が設定されていません</span>
          </div>
        </div>

        <div v-if="!gistSync.isEnabled">
          <div class="form-group">
            <label for="githubToken">GitHub Personal Access Token</label>
            <input type="password" id="githubToken" v-model="syncForm.token" placeholder="GitHub Personal Access Tokenを入力">
          </div>
          <div class="form-group">
            <label for="existingGistId">既存のGist ID（任意）</label>
            <input type="text" id="existingGistId" v-model="syncForm.gistId" placeholder="他のデバイスと同期する場合のみ入力">
          </div>
          <div class="sync-actions">
            <button class="sync-btn success" @click="saveGitHubSync">GitHub同期を開始</button>
          </div>
        </div>

        <div v-else class="sync-actions">
          <button class="sync-btn secondary" @click="copyGistId">Gist IDコピー</button>
          <button class="sync-btn danger" @click="clearGitHubSync">設定を解除</button>
        </div>
      </div>

      <div class="settings-section">
        <h3><i class="fas fa-info-circle"></i> アプリ情報</h3>
        <p>とりっぺんちゃん - 旅行予定調整サイト<br>
        ETag同期・短ポーリング対応版</p>
      </div>
    </div>
  </div>
</div>

<div v-for="modal in modals" :key="modal.id" class="modal fade" :id="modal.id" tabindex="-1">
  <div class="modal-dialog" :class="modal.size">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{ modal.title }}</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" v-html="modal.body"></div>
      <div class="modal-footer" v-html="modal.footer"></div>
    </div>
  </div>
</div>
</div> <!-- #app -->

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const { createApp } = Vue;

// GitHub Gist同期システム（ETag/If-Match + 短ポーリング + 412自動マージ LWW）
const TrippenGistSync = {
  token: null,
  gistId: null,
  isEnabled: false,
  isSyncing: false,
  lastSyncTime: null,
  lastReadTime: null,
  periodicSyncInterval: null,
  hasError: false,

  // 変更フラグ管理
  hasChanged: false,
  lastDataHash: null,

  // 新規追加（ETagと高速ポーリング/キャッシュ）
  etag: null,
  lastServerDataCache: null,
  fastPollIntervalMs: 8000,
  fastPollTimer: null,
  pendingLocalChangesSnapshot: null,

  // データハッシュ計算
  calculateHash(data) {
    try {
      const sortedData = {
        events: data.data?.events || [],
        days: data.data?.days || [],
        layerOrder: data.data?.layerOrder || []
      };
      const jsonString = JSON.stringify(sortedData, Object.keys(sortedData).sort());
      let hash = 0;
      for (let i = 0; i < jsonString.length; i++) {
        const char = jsonString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0;
      }
      return hash.toString();
    } catch (error) {
      console.error('ハッシュ計算エラー:', error);
      return Date.now().toString();
    }
  },

  // 変更フラグ設定（スナップショット取得に変更）
  markChanged() {
    this.hasChanged = true;
    try {
      const data = window.app ? window.app.collectCurrentLocalData() : null;
      if (data) this.pendingLocalChangesSnapshot = data;
    } catch (e) {
      console.warn('failed to snapshot local changes', e);
    }
  },

  // 変更フラグリセット
  resetChanged() {
    this.hasChanged = false;
  },

  // 暗号化/復号（既存）
  _encrypt(text, key = 'trippen_secret_key') {
    if (!text) return '';
    try {
      let result = '';
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
      }
      return btoa(result);
    } catch (error) {
      console.error('暗号化エラー:', error);
      throw new Error('暗号化処理に失敗しました');
    }
  },

  _decrypt(encryptedText, key = 'trippen_secret_key') {
    if (!encryptedText) return '';
    try {
      const text = atob(encryptedText);
      let result = '';
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
      }
      return result;
    } catch (error) {
      console.error('復号化エラー:', error);
      throw new Error('復号化に失敗しました');
    }
  },

  getUTCTimestamp() {
    return new Date().toISOString();
  },

  // ランタイム状態の保存/復元（ETagなど）
  saveRuntimeState() {
    try {
      const current = JSON.parse(localStorage.getItem('trippen_gist_config') || '{}');
      current._runtime = current._runtime || {};
      current._runtime.etag = this.etag;
      localStorage.setItem('trippen_gist_config', JSON.stringify(current));
    } catch (e) { console.warn('runtime state save failed', e); }
  },

  loadRuntimeState() {
    try {
      const current = JSON.parse(localStorage.getItem('trippen_gist_config') || '{}');
      const rt = current?._runtime;
      if (rt?.etag) this.etag = rt.etag;
    } catch (e) { /* ignore */ }
  },

  loadConfig() {
    try {
      const configStr = localStorage.getItem('trippen_gist_config');
      if (!configStr) return null;
      const config = JSON.parse(configStr);

      if (config.encryptedToken) {
        this.token = this._decrypt(config.encryptedToken);
      }
      this.gistId = config.gistId || null;
      this.lastSyncTime = config.lastSyncTime || null;
      this.lastReadTime = config.lastReadTime || null;
      this.lastDataHash = config.lastDataHash || null;
      this.isEnabled = !!(this.token);

      // 追加: ランタイム状態復元
      this.loadRuntimeState();

      return config;
    } catch (error) {
      console.error('設定読み込みエラー:', error);
      this.hasError = true;
      this.isEnabled = false;
      return null;
    }
  },

  init(token, gistId = null) {
    if (!token || typeof token !== 'string' || token.trim().length === 0) {
      throw new Error('有効なトークンが必要です');
    }
    const encryptedToken = this._encrypt(token.trim());
    this.token = token.trim();
    this.gistId = gistId ? gistId.trim() : null;
    this.isEnabled = true;
    this.hasError = false;
    this.hasChanged = false;

    const configData = {
      encryptedToken,
      gistId: this.gistId,
      isEnabled: this.isEnabled,
      configuredAt: this.getUTCTimestamp(),
      lastSyncTime: this.lastSyncTime,
      lastReadTime: this.lastReadTime,
      lastDataHash: this.lastDataHash,
      version: '3.0'
    };
    localStorage.setItem('trippen_gist_config', JSON.stringify(configData));

    this.startPeriodicSync();
  },

  // 60秒毎の自動書き込み + 8秒毎の新着ポーリング
  startPeriodicSync() {
    if (this.periodicSyncInterval) clearInterval(this.periodicSyncInterval);
    this.periodicSyncInterval = setInterval(async () => { await this.autoWriteToCloud(); }, 60000);

    if (this.fastPollTimer) clearInterval(this.fastPollTimer);
    this.fastPollTimer = setInterval(async () => {
      try {
        if (!this.isEnabled || !this.token || !this.gistId) return;
        const changed = await this.checkForNewerCloudDataByETag();
        if (!changed) return;
        const latest = await this.loadFromCloud(true);
        if (latest?.data && window.app?.applyServerDataIfNew) {
          window.app.applyServerDataIfNew(latest);
        }
      } catch (e) {
        console.warn('fast poll failed', e);
      }
    }, this.fastPollIntervalMs);
  },

  stopPeriodicSync() {
    if (this.periodicSyncInterval) {
      clearInterval(this.periodicSyncInterval);
      this.periodicSyncInterval = null;
    }
    if (this.fastPollTimer) {
      clearInterval(this.fastPollTimer);
      this.fastPollTimer = null;
    }
  },

  collectSyncData() {
    const events = JSON.parse(localStorage.getItem('trippenEvents') || '[]');
    const days = JSON.parse(localStorage.getItem('trippenDays') || '[]');
    const layerOrder = JSON.parse(localStorage.getItem('trippenLayerOrder') || '[]');
    return {
      version: '3.0',
      syncTime: this.getUTCTimestamp(),
      data: { events, days, layerOrder }
    };
  },
  async loadFromCloud(useConditional = true) {
    if (!this.token) throw new Error('トークンが設定されていません');
    if (!this.gistId) throw new Error('Gist IDが設定されていません');

    const headers = {
      'Authorization': `token ${this.token}`,
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'Trippen-App'
    };
    if (useConditional && this.etag) {
      headers['If-None-Match'] = this.etag;
    }

    const res = await fetch(`https://api.github.com/gists/${this.gistId}`, { headers });

    if (res.status === 304) {
      this.lastReadTime = this.getUTCTimestamp();
      this.saveLastReadTime();
      return this.lastServerDataCache;
    }

    if (!res.ok) {
      const t = await res.text().catch(() => '');
      throw new Error(`GitHub API エラー: ${res.status} ${t}`);
    }

    const newEtag = res.headers.get('ETag');
    const gist = await res.json();

    if (!gist.files || !gist.files['trippen_data.json']) {
      throw new Error('Gistにtrippen_data.jsonファイルが見つかりません');
    }

    const content = gist.files['trippen_data.json'].content || '';
    const parsed = content ? JSON.parse(content) : { version: '3.0', data: { events: [], days: [], layerOrder: [] } };

    if (newEtag) {
      this.etag = newEtag;
      this.saveRuntimeState();
    }

    this.lastServerDataCache = parsed;
    this.lastDataHash = this.calculateHash(parsed);
    this.lastReadTime = this.getUTCTimestamp();
    this.saveLastReadTime();
    this.resetChanged();

    return parsed;
  },

  async checkForNewerCloudDataByETag() {
    if (!this.token || !this.gistId) return false;
    const headers = {
      'Authorization': `token ${this.token}`,
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'Trippen-App'
    };
    if (this.etag) headers['If-None-Match'] = this.etag;
    const res = await fetch(`https://api.github.com/gists/${this.gistId}`, { headers });
    if (res.status === 304) return false;
    if (!res.ok) return false;
    return true;
  },

  mergeServerWithLocal(serverJson, localSnapshot) {
    if (!localSnapshot || !localSnapshot.data) return serverJson;

    const s = JSON.parse(JSON.stringify(serverJson || { data: { events: [], days: [], layerOrder: [] } }));
    const l = localSnapshot;

    // events: IDで突き合わせ、localを後勝ちで適用（LWW）
    const byId = new Map();
    (s.data.events || []).forEach(ev => byId.set(String(ev.id), { ...ev }));
    (l.data.events || []).forEach(lev => {
      const key = String(lev.id);
      const curr = byId.get(key);
      if (!curr) {
        byId.set(key, { ...lev });
      } else {
        byId.set(key, { ...curr, ...lev });
      }
    });
    s.data.events = Array.from(byId.values());

    // days: ローカルに値があれば置換
    if (Array.isArray(l.data.days)) {
      s.data.days = JSON.parse(JSON.stringify(l.data.days));
    }

    // layerOrder: ローカル優先
    if (Array.isArray(l.data.layerOrder)) {
      s.data.layerOrder = JSON.parse(JSON.stringify(l.data.layerOrder));
    }

    s.version = s.version || '3.0';
    s.syncTime = this.getUTCTimestamp();
    return s;
  },

  async syncToCloud(data) {
    if (!this.token) {
      console.error('トークンが設定されていません');
      return false;
    }

    const payload = {
      description: `とりっぺんちゃん 旅行データ バックアップ - ${new Date().toLocaleString('ja-JP')}`,
      public: false,
      files: { "trippen_data.json": { content: JSON.stringify(data, null, 2) } }
    };

    const url = this.gistId ? `https://api.github.com/gists/${this.gistId}` : 'https://api.github.com/gists';
    const method = this.gistId ? 'PATCH' : 'POST';

    const headersBase = {
      'Authorization': `token ${this.token}`,
      'Content-Type': 'application/json',
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'Trippen-App'
    };
    if (this.gistId && this.etag) {
      headersBase['If-Match'] = this.etag;
    }

    const doRequest = async (headers, body) => {
      return await fetch(url, { method, headers, body: JSON.stringify(body) });
    };

    let res = await doRequest(headersBase, payload);

    if (res.status === 412) {
      // ETag不一致 → 最新GETしてローカル変更再適用（LWW）→再PATCH
      const latest = await this.loadFromCloud(false);
      const merged = this.mergeServerWithLocal(latest, this.pendingLocalChangesSnapshot || this.collectSyncData());

      const retryPayload = {
        description: payload.description,
        public: false,
        files: { "trippen_data.json": { content: JSON.stringify(merged, null, 2) } }
      };
      const retryHeaders = { ...headersBase, 'If-Match': this.etag || '' };
      res = await doRequest(retryHeaders, retryPayload);
    }

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      console.error('書き込み失敗:', res.status, text);
      return false;
    }

    const result = await res.json();

    if (!this.gistId && result.id) {
      this.gistId = result.id;
      this.saveGistId(result.id);
    }

    const newEtag = res.headers.get('ETag');
    if (newEtag) {
      this.etag = newEtag;
      this.saveRuntimeState();
    }

    try {
      const file = result.files?.['trippen_data.json'];
      if (file?.content) {
        this.lastServerDataCache = JSON.parse(file.content);
      }
    } catch { /* ignore */ }

    return true;
  },

  async autoWriteToCloud() {
    if (!this.isEnabled || !this.token || this.isSyncing) return false;

    this.isSyncing = true;
    this.hasError = false;

    try {
      const hasNewerData = await this.checkForNewerCloudDataByETag();
      if (hasNewerData) {
        try {
          const latest = await this.loadFromCloud(true);
          if (latest?.data && window.app?.applyServerDataIfNew) {
            window.app.applyServerDataIfNew(latest);
          }
        } catch (e) {
          console.warn('auto fetch latest failed', e);
        }
        return false;
      }

      if (!this.hasChanged) return false;

      const localData = this.collectSyncData();
      const ok = await this.syncToCloud(localData);
      if (ok) {
        this.lastSyncTime = this.getUTCTimestamp();
        this.lastDataHash = this.calculateHash(localData);
        this.saveLastSyncTime();
        this.resetChanged();
        return true;
      }
      return false;
    } catch (e) {
      console.error('自動書き込みエラー:', e);
      this.hasError = true;
      return false;
    } finally {
      this.isSyncing = false;
    }
  },

  async manualWriteToCloud() {
    if (!this.isEnabled || !this.token) {
      throw new Error('GitHub同期が設定されていません');
    }
    this.isSyncing = true;
    this.hasError = false;

    try {
      const hasNewerData = await this.checkForNewerCloudDataByETag();
      if (hasNewerData) {
        try {
          const latest = await this.loadFromCloud(true);
          if (latest?.data && window.app?.applyServerDataIfNew) {
            window.app.applyServerDataIfNew(latest);
          }
        } catch {}
        throw new Error('他端末の更新を検出しました。最新を取り込みました。もう一度保存してください。');
      }

      const localData = this.collectSyncData();
      const ok = await this.syncToCloud(localData);
      if (ok) {
        this.lastSyncTime = this.getUTCTimestamp();
        this.lastDataHash = this.calculateHash(localData);
        this.saveLastSyncTime();
        this.resetChanged();
        return true;
      }
      throw new Error('書き込みに失敗しました');
    } finally {
      this.isSyncing = false;
    }
  },

  saveGistId(gistId) {
    try {
      const currentConfigStr = localStorage.getItem('trippen_gist_config') || '{}';
      const config = JSON.parse(currentConfigStr);
      config.gistId = gistId;
      config.lastSyncTime = this.lastSyncTime;
      config.lastReadTime = this.lastReadTime;
      config.lastDataHash = this.lastDataHash;
      localStorage.setItem('trippen_gist_config', JSON.stringify(config));
      this.gistId = gistId;
      if (window.app?.gistSync) window.app.gistSync.gistId = gistId;
    } catch {
      this.gistId = gistId;
    }
  },

  saveLastSyncTime() {
    try {
      const current = JSON.parse(localStorage.getItem('trippen_gist_config') || '{}');
      current.lastSyncTime = this.lastSyncTime;
      current.lastDataHash = this.lastDataHash;
      localStorage.setItem('trippen_gist_config', JSON.stringify(current));
    } catch {}
  },

  saveLastReadTime() {
    try {
      const current = JSON.parse(localStorage.getItem('trippen_gist_config') || '{}');
      current.lastReadTime = this.lastReadTime;
      current.lastDataHash = this.lastDataHash;
      localStorage.setItem('trippen_gist_config', JSON.stringify(current));
    } catch {}
  },

  clear() {
    this.stopPeriodicSync();
    localStorage.removeItem('trippen_gist_config');
    this.token = null;
    this.gistId = null;
    this.isEnabled = false;
    this.lastSyncTime = null;
    this.lastReadTime = null;
    this.hasError = false;
    this.hasChanged = false;
    this.lastDataHash = null;
    this.etag = null;
    this.lastServerDataCache = null;
    this.pendingLocalChangesSnapshot = null;
  }
};

// Vueアプリ本体
const app = createApp({
  data() {
    return {
      tripInitialized: false,
      tripStartDate: '',
      tripEndDate: '',
      today: new Date().toISOString().split('T')[0],
      hasExistingData: false,
      tripDays: [],
      activeDay: 0,

      showMobilePopup: false,
      selectedDayForPopup: null,
      selectedDayIndex: null,

      scrollPosition: 0,
      maxScrollPosition: 0,
      timeSlots: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23],

      events: [],
      editModeEvent: null,
      clipboardEvent: null,
      showContextMenu: false,
      contextMenuStyle: {},
      pasteTargetTime: null,

      isMobile: false,
      touchStartTime: 0,
      touchStartPosition: { x: 0, y: 0 },
      longPressTimer: null,
      longPressExecuted: false,
      eventTouchOffset: { x: 0, y: 0 },
      draggingEvent: null,
      isDragComplete: false,
      isResizeComplete: false,
      dragStarted: false,
      longPressEventData: null,
      longPressEvent: null,
      readyToMoveEventId: null,

      showMapModal: false,
      map: null,
      selectedCoordinates: null,
      mapMarker: null,

      eventForm: {
        title: '',
        dayIndex: 0,
        startTime: '09:00',
        endTime: '10:00',
        category: 'travel',
        description: '',
        coordinates: ''
      },

      modals: [],

      eventLayerOrder: [],
      baseZIndex: 10,
      maxZIndex: 10,

      weatherCache: {},
      weatherCacheExpiry: 6 * 60 * 60 * 1000,
      showWeatherPopup: false,
      weatherPopupUrl: '',

      showSettingsModal: false,
      showConflictModal: false,

      gistSync: {
        isEnabled: false,
        gistId: null,
        lastSyncTime: null,
        lastReadTime: null,
        isSyncing: false,
        isLoading: false,
        hasError: false
      },
      syncForm: { token: '', gistId: '' }
    };
  },

  methods: {
    // サーバーデータをUIへ反映（短ポーリングで新着時に使用）
    applyServerDataIfNew(serverJson) {
      if (!serverJson?.data) return;

      const s = serverJson.data;
      this.events = [...(s.events || [])];
      this.tripDays = [...(s.days || [])];
      this.eventLayerOrder = [...(s.layerOrder || [])];

      localStorage.setItem('trippenEvents', JSON.stringify(this.events));
      localStorage.setItem('trippenDays', JSON.stringify(this.tripDays));
      localStorage.setItem('trippenLayerOrder', JSON.stringify(this.eventLayerOrder));

      if (this.tripDays.length > 0) this.tripInitialized = true;
      this.$nextTick(() => this.loadWeatherForAllEvents());
    },

    // ローカルの現在状態をスナップショット（LWW再適用用）
    collectCurrentLocalData() {
      return {
        version: '3.0',
        syncTime: new Date().toISOString(),
        data: {
          events: JSON.parse(JSON.stringify(this.events || [])),
          days: JSON.parse(JSON.stringify(this.tripDays || [])),
          layerOrder: JSON.parse(JSON.stringify(this.eventLayerOrder || []))
        }
      };
    },

    // 以降は既存ロジック（添付のUI/操作処理と同等）。必要箇所のみ変更済み。
    linkifyUrls(text) {
      if (!text) return text;
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
    },

    checkExistingData() {
      this.hasExistingData = !!(localStorage.getItem('trippenEvents') && localStorage.getItem('trippenDays'));
    },

    loadExistingData() {
      this.loadData();
      if (this.tripDays.length > 0) this.tripInitialized = true;
    },

    initializeTripDays() {
      if (!this.tripStartDate || !this.tripEndDate || this.tripStartDate > this.tripEndDate) {
        alert('正しい日付を選択してください');
        return;
      }
      this.tripDays = this.generateTripDays(this.tripStartDate, this.tripEndDate);
      this.activeDay = 0;
      this.tripInitialized = true;
      this.saveData();
    },

    generateTripDays(startDate, endDate) {
      const days = [];
      const start = new Date(startDate);
      const end = new Date(endDate);
      const dayNames = ['日','月','火','水','木','金','土'];
      let dayNumber = 1;
      for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
        days.push({
          id: Date.now() + dayNumber + Math.random(),
          dayNumber: dayNumber++,
          date: `${date.getMonth() + 1}/${date.getDate()}(${dayNames[date.getDay()]})`,
          fullDate: date.toISOString().split('T')[0]
        });
      }
      return days;
    },

    setActiveDay(index) { this.activeDay = index; },

    detectMobile() { this.isMobile = window.innerWidth <= 768 || 'ontouchstart' in window; },

    addDayImmediately() {
      const startDate = this.tripDays[0].fullDate;
      this.tripDays = this.generateConsecutiveDays(startDate, this.tripDays.length + 1);
      this.saveData();
    },

    deleteDay(index) {
      if (this.tripDays.length <= 1) {
        alert('最低1つの日程は必要です');
        return;
      }
      if (confirm(`${this.tripDays[index].dayNumber}日目を削除しますか？`)) {
        this.events = this.events.filter(e => e.dayIndex !== index)
          .map(e => e.dayIndex > index ? { ...e, dayIndex: e.dayIndex - 1 } : e);
        this.tripDays = this.generateConsecutiveDays(this.tripDays[0].fullDate, this.tripDays.length - 1);
        if (this.activeDay >= this.tripDays.length) this.activeDay = this.tripDays.length - 1;
        this.saveData();
      }
    },

    generateConsecutiveDays(startDate, dayCount) {
      const days = [];
      const start = new Date(startDate);
      const dayNames = ['日','月','火','水','木','金','土'];
      for (let i = 0; i < dayCount; i++) {
        const date = new Date(start);
        date.setDate(start.getDate() + i);
        days.push({
          id: Date.now() + i + Math.random(),
          dayNumber: i + 1,
          date: `${date.getMonth() + 1}/${date.getDate()}(${dayNames[date.getDay()]})`,
          fullDate: date.toISOString().split('T')[0]
        });
      }
      return days;
    },

    handleDateClick(index) {
      if (index === 0) this.openStartDateModal();
      else this.setActiveDay(index);
    },

    getCurrentDayEvents() {
      return this.events
        .filter(event => event.dayIndex === this.activeDay)
        .map(event => ({ ...event, inlineText: `${event.title}（${event.startTime}-${event.endTime}）` }));
    },

    checkEventOverlap(a, b) {
      if (a.dayIndex !== b.dayIndex) return false;
      const sa = this.timeToMinutes(a.startTime);
      const ea = this.timeToMinutes(a.endTime);
      const sb = this.timeToMinutes(b.startTime);
      const eb = this.timeToMinutes(b.endTime);
      return !(ea <= sb || eb <= sa);
    },

    getOverlappingEvents(targetEvent) {
      return this.events.filter(ev => ev.id !== targetEvent.id && this.checkEventOverlap(targetEvent, ev));
    },

    updateEventZIndex(eventId) {
      const overlapping = this.getOverlappingEvents(this.events.find(e => e.id === eventId) || {});
      if (overlapping.length === 0) return;
      this.eventLayerOrder = this.eventLayerOrder.filter(id => id !== eventId);
      this.eventLayerOrder.push(eventId);
      this.maxZIndex = Math.max(this.maxZIndex, this.baseZIndex + this.eventLayerOrder.length);
      this.saveLayerOrder();
    },

    handleEventClick(e, eventData) {
      if (this.isDragComplete) { this.isDragComplete = false; return; }
      if (this.isResizeComplete) { this.isResizeComplete = false; return; }
      if (this.draggingEvent) return;
      if (this.editModeEvent && this.editModeEvent.id === eventData.id) return;
      if (!e.target.closest('.event-action-btn') &&
          !e.target.closest('.resize-handle') &&
          !e.target.closest('.weather-emoji-top-left')) {
        this.openDetailModal(eventData);
      }
    },

    handleEventMouseDown(e, eventData) {
      if (this.editModeEvent && this.editModeEvent.id === eventData.id) {
        if (!e.target.closest('.event-action-btn') && !e.target.closest('.resize-handle')) {
          e.preventDefault();
          e.stopPropagation();
          this.startEventDrag(e, eventData);
        }
      }
    },

    handleEventContextMenu(event, eventData) {
      event.preventDefault();
      event.stopPropagation();
      this.editModeEvent = this.editModeEvent?.id === eventData.id ? null : eventData;
      if (navigator.vibrate) navigator.vibrate(50);
    },

    startEventDrag(event, eventData) {
      this.draggingEvent = eventData;
      this.isDragComplete = false;
      const container = this.$refs.scrollContainer || this.$refs.mobileTimelineContainer;
      const rect = container.getBoundingClientRect();
      const timelineHeader = container.querySelector('.timeline-header');
      const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
      const centerOffset = (this.timeToPixels(eventData.endTime) - this.timeToPixels(eventData.startTime)) / 2;

      const moveHandler = (e) => {
        const newCenterTop = e.clientY - rect.top - headerHeight + container.scrollTop;
        const newStartTop = newCenterTop - centerOffset;
        const snappedTop = Math.round(newStartTop / 15) * 15;
        this.updateEventTimeFromDrag(eventData, snappedTop);
      };
      const endHandler = () => {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', endHandler);
        this.draggingEvent = null;
        this.isDragComplete = true;
        this.updateEventZIndex(eventData.id);
        this.saveData();
        setTimeout(() => { this.isDragComplete = false; }, 150);
      };
      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', endHandler);
    },

    startEventDragTouch(event, eventData) {
      this.draggingEvent = eventData;
      this.isDragComplete = false;
      const coords = event.touches[0];
      const container = this.$refs.mobileTimelineContainer || this.$refs.scrollContainer;
      const rect = container.getBoundingClientRect();
      const timelineHeader = container.querySelector('.timeline-header');
      const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
      const centerOffset = (this.timeToPixels(eventData.endTime) - this.timeToPixels(eventData.startTime)) / 2;

      const moveHandler = (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const newCenterTop = touch.clientY - rect.top - headerHeight + container.scrollTop;
        const newStartTop = newCenterTop - centerOffset;
        const snappedTop = Math.round(newStartTop / 15) * 15;
        this.updateEventTimeFromDrag(eventData, snappedTop);
      };
      const endHandler = () => {
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('touchend', endHandler);
        this.draggingEvent = null;
        this.isDragComplete = true;
        this.updateEventZIndex(eventData.id);
        this.saveData();
        setTimeout(() => { this.isDragComplete = false; }, 150);
      };
      document.addEventListener('touchmove', moveHandler, { passive: false });
      document.addEventListener('touchend', endHandler, { passive: true });
    },

    updateEventTimeFromDrag(eventData, snappedTop) {
      const minTime = '04:00';
      const maxTime = '24:00';
      const idx = this.events.findIndex(ev => ev.id === eventData.id);
      if (idx === -1) return;
      const duration = this.timeToMinutes(this.events[idx].endTime) - this.timeToMinutes(this.events[idx].startTime);
      const newTime = this.pixelsToTime(snappedTop);
      const newEndTime = this.minutesToTime(this.timeToMinutes(newTime) + duration);

      if (newTime < minTime) {
        this.events[idx].startTime = minTime;
        this.events[idx].endTime = this.minutesToTime(this.timeToMinutes(minTime) + duration);
        return;
      }
      if (newEndTime > maxTime) {
        this.events[idx].endTime = maxTime;
        this.events[idx].startTime = this.minutesToTime(this.timeToMinutes(maxTime) - duration);
        return;
      }
      this.events[idx].startTime = newTime;
      this.events[idx].endTime = newEndTime;
    },

    handleMobileDayTouchStart(event, index) {
      this.touchStartTime = Date.now();
      this.longPressTimer = setTimeout(() => {
        if (navigator.vibrate) navigator.vibrate(50);
        this.showMobilePopupForDay(index);
      }, 800);
    },

    handleMobileDayTouchEnd(event, index) {
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
      if (Date.now() - this.touchStartTime < 500) this.setActiveDay(index);
    },

    showMobilePopupForDay(index) {
      this.selectedDayForPopup = this.tripDays[index];
      this.selectedDayIndex = index;
      this.showMobilePopup = true;
    },

    closeMobilePopup() {
      this.showMobilePopup = false;
      this.selectedDayForPopup = null;
      this.selectedDayIndex = null;
    },

    openStartDateModalFromPopup() {
      this.closeMobilePopup();
      setTimeout(() => this.openStartDateModal(), 300);
    },

    addDayFromPopup() {
      this.closeMobilePopup();
      setTimeout(() => this.addDayImmediately(), 300);
    },

    deleteDayFromPopup() {
      const index = this.selectedDayIndex;
      this.closeMobilePopup();
      setTimeout(() => index !== null && this.deleteDay(index), 300);
    },

    updateScrollPosition() {
      const container = this.$refs.mobileScrollContainer;
      if (!container) return;
      this.scrollPosition = container.scrollLeft;
      this.maxScrollPosition = container.scrollWidth - container.clientWidth;
    },

    scrollToDirection(direction) {
      const container = this.$refs.mobileScrollContainer;
      if (!container) return;
      container.scrollBy({ left: direction === 'left' ? -120 : 120, behavior: 'smooth' });
    },

    handleEventTouchStart(event, eventData) {
      if (this.isDragComplete) return;
      if (this.draggingEvent) return;

      if (this.editModeEvent && this.editModeEvent.id === eventData.id) {
        if (!event.target.closest('.event-action-btn') && !event.target.closest('.resize-handle')) {
          event.preventDefault();
          event.stopPropagation();
          this.startEventDragTouch(event, eventData);
        }
      } else {
        if (!event.target.closest('.event-action-btn') &&
            !event.target.closest('.resize-handle') &&
            !event.target.closest('.weather-emoji-top-left')) {
          event.preventDefault();
          event.stopPropagation();
          this.touchStartTime = Date.now();
          this.longPressExecuted = false;
          this.dragStarted = false;
          this.longPressEventData = eventData;
          this.longPressEvent = event;
          this.readyToMoveEventId = null;
          this.touchStartPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
          this.longPressTimer = setTimeout(() => {
            this.longPressExecuted = true;
            this.readyToMoveEventId = eventData.id;
            if (navigator.vibrate) navigator.vibrate(50);
          }, 500);

          const handleTouchMove = (e) => {
            if (!this.longPressExecuted) return;
            const dx = Math.abs(e.touches[0].clientX - this.touchStartPosition.x);
            const dy = Math.abs(e.touches[0].clientY - this.touchStartPosition.y);
            if ((dx > 5 || dy > 5) && !this.dragStarted) {
              this.dragStarted = true;
              this.editModeEvent = eventData;
              this.readyToMoveEventId = null;
              this.startEventDragTouch(this.longPressEvent, eventData);
            }
          };
          const handleTouchEnd = () => {
            if (this.longPressTimer) {
              clearTimeout(this.longPressTimer);
              this.longPressTimer = null;
            }
            const dur = Date.now() - this.touchStartTime;
            if (this.longPressExecuted && !this.dragStarted) {
              this.editModeEvent = eventData;
              this.readyToMoveEventId = null;
            } else if (!this.longPressExecuted && dur < 500) {
              this.openDetailModal(eventData);
            }
            this.dragStarted = false;
            this.longPressEventData = null;
            this.longPressEvent = null;
            this.readyToMoveEventId = null;
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
          };
          document.addEventListener('touchmove', handleTouchMove, { passive: false });
          document.addEventListener('touchend', handleTouchEnd, { passive: true });
        }
      }
    },

    handleCutButtonClick(event, eventData) {
      event.preventDefault();
      event.stopPropagation();
      this.cutEvent(eventData);
    },

    cutEvent(ev) {
      try {
        this.clipboardEvent = { ...ev };
        const idx = this.events.findIndex(e => e.id === ev.id);
        if (idx !== -1) {
          this.events.splice(idx, 1);
          this.editModeEvent = null;
          this.saveData();
          if (navigator.vibrate) navigator.vibrate([100,50,100]);
        }
      } catch (e) {
        console.error('切り取り失敗:', e);
        alert('予定の切り取りに失敗しました。');
      }
    },

    pasteFromContext() {
      if (!this.clipboardEvent) return;
      const newEvent = { ...this.clipboardEvent, id: Date.now() + Math.random(), dayIndex: this.activeDay };
      if (this.pasteTargetTime) {
        const dur = this.timeToMinutes(this.clipboardEvent.endTime) - this.timeToMinutes(this.clipboardEvent.startTime);
        const startMinutes = this.timeToMinutes(this.pasteTargetTime);
        let endMinutes = startMinutes + dur;
        if (endMinutes > 1440) endMinutes = 1440;
        newEvent.startTime = this.pasteTargetTime;
        newEvent.endTime = this.minutesToTime(endMinutes);
      }
      this.events.push(newEvent);
      this.clipboardEvent = null;
      this.hideContextMenu();
      this.saveData();
    },

    addEventFromContext() {
      if (!this.pasteTargetTime) return;
      const startMinutes = this.timeToMinutes(this.pasteTargetTime);
      const endTime = this.minutesToTime(startMinutes + 60);
      this.eventForm = {
        title: '',
        dayIndex: this.activeDay,
        startTime: this.pasteTargetTime,
        endTime,
        category: 'travel',
        description: '',
        coordinates: ''
      };
      this.hideContextMenu();
      setTimeout(() => this.openEventModal(null, true), 100);
    },

    timeToMinutes(t) { const [h,m] = t.split(':').map(Number); return h*60 + m; },
    minutesToTime(min) { const h = Math.floor(min/60), m = min%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; },
    timeToPixels(t) { const [h,m] = t.split(':').map(Number); const total = (h-4)*60+m; return total*(this.isMobile? 50/60 : 1); },
    pixelsToTime(px) {
      const total = px/(this.isMobile? 50/60 : 1);
      const rounded = Math.round(total/15)*15;
      const hours = Math.max(4, Math.min(24, Math.floor(rounded/60)+4));
      const minutes = hours === 24 ? 0 : rounded % 60;
      return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
    },

    handleScheduleContextMenu(event) {
      if (!this.isMobile) {
        event.preventDefault();
        this.showContextMenuAt(event.clientX, event.clientY, event);
      }
    },

    showContextMenuAt(x, y) {
      const container = this.isMobile ? this.$refs.mobileTimelineContainer : this.$refs.scrollContainer;
      const timelineHeader = container.querySelector('.timeline-header');
      const scheduleArea = container.querySelector('.schedule-area');
      const containerRect = container.getBoundingClientRect();
      const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
      const relativeY = y - containerRect.top - headerHeight + container.scrollTop;
      const snappedY = Math.round(relativeY / 15) * 15;
      this.pasteTargetTime = this.pixelsToTime(Math.max(0, snappedY));
      this.contextMenuStyle = { left: `${x}px`, top: `${y}px` };
      this.showContextMenu = true;
      setTimeout(() => { document.addEventListener('click', this.hideContextMenu, { once: true }); }, 100);
    },

    hideContextMenu() { this.showContextMenu = false; },

    handleScheduleTouchStart(event) {
      if (!this.isMobile) return;
      if (event.target.closest('.event-block')) return;
      this.touchStartTime = Date.now();
      this.touchStartPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
      this.longPressTimer = setTimeout(() => {
        this.showContextMenuAt(this.touchStartPosition.x, this.touchStartPosition.y, event);
        if (navigator.vibrate) navigator.vibrate(50);
      }, 500);
    },

    handleScheduleTouchMove(event) {
      if (!this.isMobile) return;
      if (event.target.closest('.event-block')) return;
      const dx = Math.abs(event.touches[0].clientX - this.touchStartPosition.x);
      const dy = Math.abs(event.touches[0].clientY - this.touchStartPosition.y);
      if (dx > 10 || dy > 10) this.clearLongPress();
    },

    handleScheduleTouchEnd(event) {
      if (!this.isMobile) return;
      if (event.target.closest('.event-block')) return;
      this.clearLongPress();
      if (Date.now() - this.touchStartTime < 300) this.editModeEvent = null;
    },

    clearLongPress() {
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
    },

    startResize(event, eventData, direction) { this.startResizeHandler(event, direction, 'mouse'); },
    startResizeTouch(event, eventData, direction) { this.startResizeHandler(event, direction, 'touch'); },

    startResizeHandler(event, direction, type) {
      event.preventDefault();
      event.stopPropagation();
      const moveEvent = type === 'touch' ? 'touchmove' : 'mousemove';
      const endEvent = type === 'touch' ? 'touchend' : 'mouseup';
      const moveHandler = (e) => {
        const coords = type === 'touch' ? e.touches[0] : e;
        const container = this.isMobile ? this.$refs.mobileTimelineContainer : this.$refs.scrollContainer;
        const rect = container.getBoundingClientRect();
        const timelineHeader = container.querySelector('.timeline-header');
        const headerHeight = timelineHeader ? timelineHeader.offsetHeight : 0;
        const y = coords.clientY - rect.top - headerHeight + container.scrollTop;
        const snappedY = Math.round(y / 15) * 15;
        const newTime = this.pixelsToTime(snappedY);
        const idx = this.events.findIndex(ev => ev.id === this.editModeEvent.id);
        if (idx === -1) return;
        if (direction === 'top' && newTime < this.events[idx].endTime) {
          this.events[idx].startTime = newTime;
        } else if (direction === 'bottom' && newTime > this.events[idx].startTime) {
          this.events[idx].endTime = newTime;
        }
      };
      const endHandler = () => {
        document.removeEventListener(moveEvent, moveHandler);
        document.removeEventListener(endEvent, endHandler);
        this.isResizeComplete = true;
        this.saveData();
        setTimeout(() => { this.isResizeComplete = false; }, 150);
      };
      document.addEventListener(moveEvent, moveHandler, { passive: false });
      document.addEventListener(endEvent, endHandler);
    },

    getEventStyle(event) {
      const startPixels = this.timeToPixels(event.startTime);
      const endPixels = this.timeToPixels(event.endTime);
      const duration = Math.max(endPixels - startPixels, this.isMobile ? 25 : 30);
      let zIndex = this.baseZIndex;
      const layerIndex = this.eventLayerOrder.indexOf(event.id);
      if (layerIndex !== -1) zIndex = this.baseZIndex + layerIndex + 1;
      return { top: `${startPixels}px`, height: `${duration}px`, minHeight: this.isMobile ? '32px' : '35px', zIndex };
    },

    getCategoryIcon(category) {
      const icons = {
        travel: 'fas fa-car',
        food: 'fas fa-utensils',
        sightseeing: 'fas fa-camera',
        accommodation: 'fas fa-bed',
        custom: 'fas fa-star'
      };
      return icons[category] || 'fas fa-calendar';
    },

    async fetchWeatherForEvent(event) {
      if (!event.coordinates) return null;
      try {
        const [lat, lng] = event.coordinates.split(',').map(Number);
        if (isNaN(lat) || isNaN(lng)) return null;
        const cacheKey = `${lat},${lng}_${event.dayIndex}`;
        const cached = this.weatherCache[cacheKey];
        if (cached && Date.now() - cached.timestamp < this.weatherCacheExpiry) return cached.data;

        const dayData = this.tripDays[event.dayIndex];
        if (!dayData) return null;

        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=weathercode&timezone=auto&start_date=${dayData.fullDate}&end_date=${dayData.fullDate}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather API request failed');
        const data = await response.json();
        const code = data.daily.weathercode[0];
        this.weatherCache[cacheKey] = { data: code, timestamp: Date.now() };
        return code;
      } catch (e) {
        console.error('天気取得失敗:', e);
        return null;
      }
    },

    getWeatherEmoji(code) {
      if (code === null || code === undefined) return '';
      const map = {0:'☀️',1:'🌤️',2:'⛅',3:'☁️',45:'🌫️',48:'🌫️',51:'🌦️',53:'🌦️',55:'🌧️',56:'🌧️',57:'🌧️',61:'🌧️',63:'🌧️',65:'🌧️',66:'🌧️',67:'🌧️',71:'🌨️',73:'🌨️',75:'🌨️',77:'🌨️',80:'🌦️',81:'🌦️',82:'🌧️',85:'🌨️',86:'🌨️',95:'⛈️',96:'⛈️',99:'⛈️'};
      return map[code] || '';
    },

    async loadWeatherForAllEvents() {
      const promises = this.events.filter(e => e.coordinates).map(e => this.fetchWeatherForEvent(e));
      await Promise.all(promises);
    },

    getEventWeatherEmoji(event) {
      if (!event.coordinates) return '';
      const cacheKey = `${event.coordinates}_${event.dayIndex}`;
      const cached = this.weatherCache[cacheKey];
      if (cached && Date.now() - cached.timestamp < this.weatherCacheExpiry) {
        return this.getWeatherEmoji(cached.data);
      }
      return '';
    },

    setLocationFromMap() {
      this.showMapModal = true;
      this.$nextTick(() => this.initializeMap());
    },

    initializeMap() {
      const initialLat = 34.7024;
      const initialLng = 135.4959;
      this.map = L.map('map').setView([initialLat, initialLng], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(this.map);
      this.map.on('click', (e) => this.handleMapClick(e));
    },

    handleMapClick(e) {
      const lat = e.latlng.lat.toFixed(6);
      const lng = e.latlng.lng.toFixed(6);
      this.selectedCoordinates = `${lat},${lng}`;
      if (this.mapMarker) this.map.removeLayer(this.mapMarker);
      this.mapMarker = L.marker([lat, lng]).addTo(this.map);
      const inp = document.getElementById('eventCoordinates');
      if (inp) inp.value = this.selectedCoordinates;
      if (navigator.vibrate) navigator.vibrate(100);
      this.closeMapModal();
    },

    closeMapModal() {
      this.showMapModal = false;
      if (this.map) { this.map.remove(); this.map = null; }
      this.mapMarker = null;
    },

    copyCoordinates() {
      const input = document.getElementById('eventCoordinates');
      if (!input || !input.value.trim()) { alert('コピーする緯度経度がありません'); return; }
      const text = input.value.trim();
      try {
        navigator.clipboard.writeText(text).then(() => {
          alert('緯度経度をコピーしました');
          if (navigator.vibrate) navigator.vibrate(100);
        }).catch(() => {
          input.select();
          document.execCommand('copy');
          alert('緯度経度をコピーしました');
          if (navigator.vibrate) navigator.vibrate(100);
        });
      } catch {
        alert('コピーに失敗しました');
      }
    },

    openGoogleMap(coordinates) {
      if (!coordinates || !coordinates.trim()) { alert('緯度経度が設定されていません'); return; }
      const coords = coordinates.trim();
      const url = `https://maps.google.co.jp/maps?ll=${coords}&z=15`;
      try {
        if (this.isMobile) window.location.href = url;
        else window.open(url, '_blank', 'noopener,noreferrer');
      } catch (e) {
        alert('Googleマップの表示に失敗しました');
      }
    },

    openDetailModal(event) {
      const eventData = typeof event === 'string' ? this.events.find(e => String(e.id) === String(event)) : event;
      if (!eventData) { alert('予定データが見つかりません'); return; }
      const safeId = String(eventData.id).replace(/'/g, "\\'");
      const safeTitle = String(eventData.title).replace(/'/g, "\\'").replace(/"/g, "&quot;");
      const safeCoordinates = String(eventData.coordinates || '').replace(/"/g, "&quot;");
      this.openModal('詳細', `
        <div class="mb-3"><h6><i class="${this.getCategoryIcon(eventData.category)}"></i> ${safeTitle}</h6></div>
        <div class="mb-3"><strong>日付:</strong> ${this.tripDays[eventData.dayIndex]?.date || '不明'}</div>
        <div class="mb-3"><strong>時間:</strong> ${eventData.startTime} - ${eventData.endTime}</div>
        ${eventData.coordinates ? `<div class="mb-3"><strong>緯度経度:</strong> ${safeCoordinates} <button type="button" class="btn btn-outline-primary btn-sm ms-2" onclick="window.app.openGoogleMap('${safeCoordinates}')" title="Googleマップで表示">🗾</button></div>` : ''}
        ${eventData.description ? `<div class="mb-3"><strong>詳細:</strong><br>${this.linkifyUrls(String(eventData.description).replace(/"/g, "&quot;"))}</div>` : ''}
      `, `
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
        <button type="button" class="btn btn-danger" onclick="window.app.deleteEventFromDetail('${safeId}')">削除</button>
        <button type="button" class="btn btn-primary" onclick="window.app.editEventFromDetail('${safeId}')">編集</button>
      `);
    },

    deleteEventFromDetail(eventId) {
      if (!confirm('この予定を削除しますか？')) return;
      const idx = this.events.findIndex(e => String(e.id) === String(eventId));
      if (idx === -1) { alert('予定が見つかりません'); return; }
      this.events.splice(idx, 1);
      this.saveData();
      this.editModeEvent = null;
      this.closeAllModals();
      if (navigator.vibrate) navigator.vibrate(100);
    },

    editEventFromDetail(eventId) {
      const ev = this.events.find(e => String(e.id) === String(eventId));
      if (!ev) { alert('予定が見つかりません'); return; }
      this.closeAllModals();
      setTimeout(() => this.openEventModal(ev), 100);
    },

    openEventModal(event = null, fromContextMenu = false) {
      const isEdit = !!event;
      if (isEdit) {
        this.eventForm = { ...event };
      } else if (!fromContextMenu) {
        this.eventForm = {
          title: '',
          dayIndex: this.activeDay,
          startTime: '09:00',
          endTime: '10:00',
          category: 'travel',
          description: '',
          coordinates: ''
        };
      }
      const modalTitle = isEdit ? '予定を編集' : '新しい予定を追加';
      const modalBody = this.generateEventModalBody();
      const modalFooter = this.generateEventModalFooter(isEdit);
      this.openModal(modalTitle, modalBody, modalFooter);
    },

    generateEventModalBody() {
      return `
        <div class="mb-3">
          <label for="eventTitle" class="form-label">予定タイトル</label>
          <input type="text" class="form-control" id="eventTitle" value="${this.eventForm.title.replace(/"/g, '&quot;')}" placeholder="予定のタイトルを入力">
        </div>
        <div class="mb-3">
          <label for="eventDay" class="form-label">日程</label>
          <select class="form-select" id="eventDay">
            ${this.tripDays.map((d, i) =>
              `<option value="${i}" ${this.eventForm.dayIndex === i ? 'selected' : ''}>${d.dayNumber}日目 (${d.date})</option>`
            ).join('')}
          </select>
        </div>
        <div class="row">
          <div class="col-md-6">
            <div class="mb-3">
              <label for="eventStartTime" class="form-label">開始時間</label>
              <input type="time" class="form-control" id="eventStartTime" value="${this.eventForm.startTime}" min="04:00" max="23:59">
            </div>
          </div>
          <div class="col-md-6">
            <div class="mb-3">
              <label for="eventEndTime" class="form-label">終了時間</label>
              <input type="time" class="form-control" id="eventEndTime" value="${this.eventForm.endTime}" min="04:00" max="24:00">
            </div>
          </div>
        </div>
        <div class="mb-3">
          <label for="eventCategory" class="form-label">カテゴリー</label>
          <select class="form-select" id="eventCategory">
            <option value="travel" ${this.eventForm.category === 'travel' ? 'selected' : ''}>🚗 移動</option>
            <option value="food" ${this.eventForm.category === 'food' ? 'selected' : ''}>🍽️ 食事</option>
            <option value="sightseeing" ${this.eventForm.category === 'sightseeing' ? 'selected' : ''}>📸 観光</option>
            <option value="accommodation" ${this.eventForm.category === 'accommodation' ? 'selected' : ''}>🏨 宿泊</option>
            <option value="custom" ${this.eventForm.category === 'custom' ? 'selected' : ''}>⭐ その他</option>
          </select>
        </div>
        <div class="mb-3">
          <label for="eventCoordinates" class="form-label">緯度経度 (オプション)</label>
          <div class="input-group">
            <input type="text" class="form-control" id="eventCoordinates" value="${this.eventForm.coordinates.replace(/"/g, '&quot;')}" placeholder="例: 34.702485,135.495951">
            <button class="btn btn-outline-secondary" type="button" onclick="window.app.setLocationFromMap()" title="地図から選択">🗾</button>
            <button class="btn btn-outline-secondary" type="button" onclick="window.app.copyCoordinates()" title="コピー">📋</button>
          </div>
          <div class="form-text">地図から位置を選択するか、緯度,経度の形式で入力してください</div>
        </div>
        <div class="mb-3">
          <label for="eventDescription" class="form-label">詳細 (オプション)</label>
          <textarea class="form-control" id="eventDescription" rows="3" placeholder="予定の詳細を入力">${this.eventForm.description.replace(/"/g, '&quot;')}</textarea>
        </div>
      `;
    },

    generateEventModalFooter(isEdit) {
      return `
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
        <button type="button" class="btn btn-primary" onclick="window.app.saveEvent(${isEdit})">${isEdit ? '更新' : '追加'}</button>
      `;
    },

    saveEvent(isEdit) {
      const title = document.getElementById('eventTitle').value.trim();
      const dayIndex = parseInt(document.getElementById('eventDay').value);
      const startTime = document.getElementById('eventStartTime').value;
      const endTime = document.getElementById('eventEndTime').value;
      const category = document.getElementById('eventCategory').value;
      const coordinates = document.getElementById('eventCoordinates').value.trim();
      const description = document.getElementById('eventDescription').value.trim();

      if (!title) { alert('予定タイトルを入力してください'); return; }
      if (!startTime || !endTime) { alert('開始時間と終了時間を選択してください'); return; }
      if (startTime >= endTime) { alert('終了時間は開始時間より後に設定してください'); return; }
      if (coordinates && !this.validateCoordinates(coordinates)) {
        alert('緯度経度の形式が正しくありません。\n正しい形式：34.702485,135.495951'); return;
      }

      const eventData = { title, dayIndex, startTime, endTime, category, coordinates, description };

      if (isEdit) {
        const idx = this.events.findIndex(e => e.id === this.eventForm.id);
        if (idx !== -1) this.events[idx] = { ...this.events[idx], ...eventData };
      } else {
        eventData.id = Date.now() + Math.random();
        this.events.push(eventData);
      }

      this.saveData();
      this.closeAllModals();
      this.editModeEvent = null;
      this.activeDay = dayIndex;
      this.loadWeatherForAllEvents();
      if (navigator.vibrate) navigator.vibrate(100);
    },

    validateCoordinates(coordinates) {
      const coordPattern = /^-?\d+\.?\d*,-?\d+\.?\d*$/;
      if (!coordPattern.test(coordinates)) return false;
      const [lat, lng] = coordinates.split(',').map(Number);
      return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
    },

    openModal(title, body, footer, size = '') {
      const modalId = 'modal-' + Date.now();
      const modal = { id: modalId, title, body, footer, size };
      this.modals.push(modal);
      this.$nextTick(() => {
        const el = document.getElementById(modalId);
        if (el) {
          const bs = new bootstrap.Modal(el);
          bs.show();
          el.addEventListener('hidden.bs.modal', () => {
            const i = this.modals.findIndex(m => m.id === modalId);
            if (i !== -1) this.modals.splice(i, 1);
          });
        }
      });
    },

    closeAllModals() {
      this.modals.forEach(m => {
        const el = document.getElementById(m.id);
        if (el) {
          const bs = bootstrap.Modal.getInstance(el);
          if (bs) bs.hide();
        }
      });
      this.modals = [];
    },

    openStartDateModal() {
      this.openModal('開始日を変更', `
        <div class="mb-3">
          <label for="newStartDate" class="form-label">新しい開始日</label>
          <input type="date" class="form-control" id="newStartDate" value="${this.tripDays[0]?.fullDate || this.today}" min="${this.today}">
        </div>
        <div class="alert alert-warning">
          <i class="fas fa-exclamation-triangle"></i>
          <strong>注意:</strong> 開始日を変更すると、既存の予定の日程も自動的に調整されます。
        </div>
      `, `
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
        <button type="button" class="btn btn-primary" onclick="window.app.updateStartDate()">変更</button>
      `);
    },

    updateStartDate() {
      const newStartDate = document.getElementById('newStartDate').value;
      if (!newStartDate) { alert('新しい開始日を選択してください'); return; }
      if (newStartDate < this.today) { alert('開始日は今日以降の日付を選択してください'); return; }
      if (confirm('開始日を変更しますか？既存の予定も日程が調整されます。')) {
        this.tripDays = this.generateConsecutiveDays(newStartDate, this.tripDays.length);
        this.saveData();
        this.closeAllModals();
        this.loadWeatherForAllEvents();
        if (navigator.vibrate) navigator.vibrate(100);
      }
    },

    openWeatherPopup(event) {
      if (!event.coordinates) { alert('この予定には位置情報が設定されていません。'); return; }
      try {
        const [lat, lng] = event.coordinates.split(',');
        const day = this.tripDays[event.dayIndex];
        if (!day) throw new Error('該当日程が見つかりません');
        const date = day.fullDate.replace(/-/g, '');
        const hour = event.startTime.split(':')[0].padStart(2, '0');
        const datetime = `${date}${hour}00`;
        this.weatherPopupUrl = `https://nokonokotubotubo.github.io/fukunavi/?lat=${lat.trim()}&lng=${lng.trim()}&datetime=${datetime}`;
        this.showWeatherPopup = true;
      } catch (e) {
        alert('天気予報ポップアップの表示に失敗しました。');
      }
    },

    closeWeatherPopup() {
      this.showWeatherPopup = false;
      this.weatherPopupUrl = '';
    },

    openSettingsModal() { this.showSettingsModal = true; },
    closeSettingsModal() { this.showSettingsModal = false; },

    async saveGitHubSync() {
      const token = this.syncForm.token.trim();
      const gistId = this.syncForm.gistId.trim();
      if (!token) { alert('GitHub Personal Access Tokenを入力してください'); return; }
      try {
        TrippenGistSync.init(token, gistId || null);
        this.gistSync = {
          isEnabled: TrippenGistSync.isEnabled,
          gistId: TrippenGistSync.gistId,
          lastSyncTime: TrippenGistSync.lastSyncTime,
          lastReadTime: TrippenGistSync.lastReadTime,
          isSyncing: false,
          isLoading: false,
          hasError: false
        };
        // 初回は手動保存してGist作成/更新
        const ok = await TrippenGistSync.manualWriteToCloud();
        if (ok) {
          this.gistSync.gistId = TrippenGistSync.gistId;
          this.gistSync.lastSyncTime = TrippenGistSync.lastSyncTime;
          this.syncForm = { token: '', gistId: '' };
          alert('GitHub同期を開始しました\nGist ID: ' + TrippenGistSync.gistId);
        } else {
          throw new Error('初回書き込みに失敗しました');
        }
      } catch (e) {
        this.gistSync.hasError = true;
        alert('設定に失敗しました: ' + e.message);
      }
    },

    async manualSync() {
      if (!TrippenGistSync.isEnabled) { alert('GitHub同期が設定されていません'); return; }
      this.gistSync.isSyncing = true;
      try {
        const result = await TrippenGistSync.manualWriteToCloud();
        if (result) {
          this.gistSync.lastSyncTime = TrippenGistSync.lastSyncTime;
          this.gistSync.hasError = false;
          alert('手動書き込みが完了しました');
        } else {
          throw new Error('書き込みに失敗しました');
        }
      } catch (e) {
        this.gistSync.hasError = true;
        alert('書き込みに失敗しました: ' + e.message);
      } finally {
        this.gistSync.isSyncing = false;
      }
    },

    async loadFromCloud() {
      if (!TrippenGistSync.isEnabled || !TrippenGistSync.token) {
        alert('GitHub同期が設定されていません。設定画面で設定してください。');
        return;
      }
      if (!TrippenGistSync.gistId) {
        alert('Gist IDが設定されていません。最初にデータを書き込むか、既存のGist IDを設定してください。');
        return;
      }
      this.gistSync.isLoading = true;
      try {
        const cloudData = await TrippenGistSync.loadFromCloud(true);
        if (!cloudData || !cloudData.data) throw new Error('クラウドデータの形式が正しくありません');

        if (cloudData.data.events) {
          this.events = [...cloudData.data.events];
          localStorage.setItem('trippenEvents', JSON.stringify(this.events));
        }
        if (cloudData.data.days) {
          this.tripDays = [...cloudData.data.days];
          localStorage.setItem('trippenDays', JSON.stringify(this.tripDays));
          this.$nextTick(() => { this.tripInitialized = this.tripDays.length > 0; });
        }
        if (cloudData.data.layerOrder) {
          this.eventLayerOrder = [...cloudData.data.layerOrder];
          localStorage.setItem('trippenLayerOrder', JSON.stringify(this.eventLayerOrder));
        }

        this.gistSync.lastReadTime = TrippenGistSync.lastReadTime;
        this.gistSync.hasError = false;

        if (this.events.length > 0) this.loadWeatherForAllEvents();
        alert('クラウドからデータを読み込みました');
      } catch (e) {
        this.gistSync.hasError = true;
        alert(`読み込みに失敗しました\nエラー: ${e.message}`);
      } finally {
        this.gistSync.isLoading = false;
      }
    },

    handleSyncConflict() { this.showConflictModal = true; },
    closeConflictModal() { this.showConflictModal = false; },
    async forceLoadFromCloud() { this.closeConflictModal(); await this.loadFromCloud(); },

    copyGistId() {
      if (!this.gistSync.gistId) { alert('コピーするGist IDがありません'); return; }
      try {
        navigator.clipboard.writeText(this.gistSync.gistId).then(() => {
          alert('Gist IDをコピーしました');
        }).catch(() => {
          const ta = document.createElement('textarea');
          ta.value = this.gistSync.gistId;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          alert('Gist IDをコピーしました');
        });
      } catch {
        alert('コピーに失敗しました');
      }
    },

    clearGitHubSync() {
      if (!confirm('GitHub同期設定を解除しますか？')) return;
      try {
        TrippenGistSync.clear();
        this.gistSync = {
          isEnabled: false, gistId: null, lastSyncTime: null, lastReadTime: null,
          isSyncing: false, isLoading: false, hasError: false
        };
        this.syncForm = { token: '', gistId: '' };
        alert('GitHub同期設定を解除しました');
      } catch {
        alert('設定の解除に失敗しました');
      }
    },

    formatSyncTime(iso) {
      if (!iso) return '未実行';
      try { return new Date(iso).toLocaleString('ja-JP'); } catch { return '日時不明'; }
    },

    saveLayerOrder() {
      localStorage.setItem('trippenLayerOrder', JSON.stringify(this.eventLayerOrder));
      localStorage.setItem('trippenMaxZIndex', this.maxZIndex.toString());
    },

    loadLayerOrder() {
      const savedLayerOrder = localStorage.getItem('trippenLayerOrder');
      const savedMaxZIndex = localStorage.getItem('trippenMaxZIndex');
      if (savedLayerOrder) {
        try { this.eventLayerOrder = JSON.parse(savedLayerOrder); }
        catch { this.eventLayerOrder = []; }
      }
      if (savedMaxZIndex) this.maxZIndex = parseInt(savedMaxZIndex) || this.baseZIndex;
    },

    saveData() {
      localStorage.setItem('trippenEvents', JSON.stringify(this.events));
      localStorage.setItem('trippenDays', JSON.stringify(this.tripDays));
      this.saveLayerOrder();
      if (TrippenGistSync.isEnabled) TrippenGistSync.markChanged();
    },

    loadData() {
      const savedEvents = localStorage.getItem('trippenEvents');
      const savedDays = localStorage.getItem('trippenDays');
      if (savedEvents) {
        try { this.events = JSON.parse(savedEvents); } catch { this.events = []; }
      }
      if (savedDays) {
        try { this.tripDays = JSON.parse(savedDays); } catch { this.tripDays = []; }
      }
      this.loadLayerOrder();
    }
  },

  mounted() {
    this.detectMobile();
    this.checkExistingData();
    this.loadData();
    if (this.tripDays.length > 0) {
      this.tripInitialized = true;
      this.loadWeatherForAllEvents();
    }
    window.addEventListener('resize', this.detectMobile);
    window.app = this;

    const config = TrippenGistSync.loadConfig();
    if (config && TrippenGistSync.isEnabled) {
      this.gistSync = {
        isEnabled: TrippenGistSync.isEnabled,
        gistId: TrippenGistSync.gistId,
        lastSyncTime: TrippenGistSync.lastSyncTime,
        lastReadTime: TrippenGistSync.lastReadTime,
        isSyncing: false,
        isLoading: false,
        hasError: false
      };
      TrippenGistSync.startPeriodicSync();

      if (TrippenGistSync.gistId) {
        setTimeout(async () => {
          try { await TrippenGistSync.loadFromCloud(true).then(d => d && this.applyServerDataIfNew(d)); }
          catch (e) { /* 初回読み込み失敗は無視 */ }
        }, 1500);
      }
    }
  }
}).mount('#app');
</script>
</body>
</html>
